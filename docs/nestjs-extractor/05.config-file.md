# 設定ファイル設計

Updated: 2025/12/30 22:20

## 目的

プロジェクト固有の認証ガード名や公開デコレーター名を設定可能にし、認証判定の精度を向上させる。

---

## 設定ファイル仕様

### ファイル名と配置

| 優先順位 | ファイル名 | 配置場所 |
|----------|-----------|----------|
| 1 | CLI `--config` で指定 | 任意 |
| 2 | `extractor.config.yaml` | プロジェクトルート |
| 3 | `extractor.config.json` | プロジェクトルート |
| 4 | `package.json` の `extractorConfig` キー | プロジェクトルート |

### 形式

YAML（推奨）またはJSON。YAMLはコメントが書けるため推奨。

---

## 設定スキーマ

### 完全な設定例

```yaml
# extractor.config.yaml

# フレームワーク共通設定
common:
  # 出力形式
  outputFormat: yaml  # yaml | json
  # レスポンス型抽出
  extractResponses: true
  responseDepth: 3

# NestJS固有設定
nestjs:
  # 認証ガード設定
  auth:
    # 認証ガードとして扱うガード名パターン（正規表現）
    # デフォルト: AuthGuard継承クラスを自動検出
    guardPatterns:
      - ".*AuthGuard$"
      - ".*JwtGuard$"

    # 明示的に認証ガードとして扱うガード名
    authGuards:
      - JwtAuthGuard
      - JwtAuthPatientGuard
      - JwtAuthMedicalGuard
      - ApiKeyAuthGuard

    # 認証ガードから除外するガード名
    excludeGuards:
      - ThrottlerGuard
      - RateLimitGuard

    # 公開エンドポイントを示すデコレーター名
    publicDecorators:
      - Public
      - SkipAuth
      - AllowAnonymous

    # 公開エンドポイントを示すメタデータキー
    publicMetadataKeys:
      - isPublic
      - IS_PUBLIC_KEY
      - skipAuth

  # パラメーターデコレーター設定
  params:
    # カスタムパラメーターデコレーターの追加
    customDecorators:
      - name: Jwt
        type: custom
        description: "JWT認証情報を注入"
      - name: CurrentUser
        type: custom
        description: "現在のユーザー情報を注入"

# Fastify固有設定（将来の拡張用）
fastify:
  auth:
    # 認証ミドルウェア/プラグイン名
    middlewareNames:
      - authenticate
      - verifyJWT
```

### 最小設定例

```yaml
# extractor.config.yaml
nestjs:
  auth:
    authGuards:
      - JwtAuthGuard
```

---

## 型定義

```typescript
// src/types/config.ts

/**
 * エクストラクター設定ファイルの型
 */
export type ExtractorConfig = {
  readonly common?: CommonConfig;
  readonly nestjs?: NestJSConfig;
  readonly fastify?: FastifyConfig;
};

/**
 * 共通設定
 */
export type CommonConfig = {
  readonly outputFormat?: 'yaml' | 'json';
  readonly extractResponses?: boolean;
  readonly responseDepth?: number;
};

/**
 * NestJS固有設定
 */
export type NestJSConfig = {
  readonly auth?: NestJSAuthConfigFile;
  readonly params?: NestJSParamsConfig;
};

/**
 * NestJS認証設定（設定ファイル用）
 */
export type NestJSAuthConfigFile = {
  /** 認証ガードとして扱うガード名パターン（正規表現） */
  readonly guardPatterns?: readonly string[];
  /** 明示的に認証ガードとして扱うガード名 */
  readonly authGuards?: readonly string[];
  /** 認証ガードから除外するガード名 */
  readonly excludeGuards?: readonly string[];
  /** 公開エンドポイントを示すデコレーター名 */
  readonly publicDecorators?: readonly string[];
  /** 公開エンドポイントを示すメタデータキー */
  readonly publicMetadataKeys?: readonly string[];
};

/**
 * NestJSパラメーター設定
 */
export type NestJSParamsConfig = {
  readonly customDecorators?: readonly CustomDecoratorConfig[];
};

/**
 * カスタムデコレーター設定
 */
export type CustomDecoratorConfig = {
  readonly name: string;
  readonly type: 'custom';
  readonly description?: string;
};

/**
 * Fastify固有設定（将来の拡張用）
 */
export type FastifyConfig = {
  readonly auth?: FastifyAuthConfigFile;
};

export type FastifyAuthConfigFile = {
  readonly middlewareNames?: readonly string[];
};
```

---

## デフォルト値

設定ファイルがない場合、またはキーが未指定の場合に使用するデフォルト値:

```typescript
// src/config/defaults.ts

export const DEFAULT_EXTRACTOR_CONFIG: ExtractorConfig = {
  common: {
    outputFormat: 'yaml',
    extractResponses: false,
    responseDepth: 2,
  },
  nestjs: {
    auth: {
      guardPatterns: [
        '.*AuthGuard$',
        '.*JwtGuard$',
        '.*SessionGuard$',
        '.*TokenGuard$',
      ],
      authGuards: [],
      excludeGuards: [
        'ThrottlerGuard',
        'RateLimitGuard',
      ],
      publicDecorators: [
        'Public',
        'SkipAuth',
        'AllowAnonymous',
      ],
      publicMetadataKeys: [
        'isPublic',
        'IS_PUBLIC_KEY',
        'skipAuth',
      ],
    },
    params: {
      customDecorators: [],
    },
  },
  fastify: {
    auth: {
      middlewareNames: [
        'authenticate',
        'verifyJWT',
        'requireAuth',
      ],
    },
  },
};
```

---

## 設定読み込みロジック

### 読み込み順序と優先度

```
1. CLI引数（最優先）
   ↓ マージ
2. --config で指定されたファイル
   ↓ マージ
3. extractor.config.yaml（プロジェクトルート）
   ↓ マージ
4. extractor.config.json（プロジェクトルート）
   ↓ マージ
5. package.json の extractorConfig キー
   ↓ マージ
6. デフォルト値
```

### 実装

```typescript
// src/config/loader.ts

import { parse as parseYaml } from 'yaml';
import type { ExtractorConfig } from '../types/config';
import { DEFAULT_EXTRACTOR_CONFIG } from './defaults';

export class ConfigLoader {
  /**
   * 設定を読み込む
   */
  async load(
    projectRoot: string,
    cliConfigPath?: string,
  ): Promise<ExtractorConfig> {
    const configs: ExtractorConfig[] = [];

    // 1. CLI指定の設定ファイル
    if (cliConfigPath) {
      const config = await this.loadFile(cliConfigPath);
      if (config) configs.push(config);
    }

    // 2. extractor.config.yaml
    const yamlConfig = await this.loadFile(
      `${projectRoot}/extractor.config.yaml`
    );
    if (yamlConfig) configs.push(yamlConfig);

    // 3. extractor.config.json
    const jsonConfig = await this.loadFile(
      `${projectRoot}/extractor.config.json`
    );
    if (jsonConfig) configs.push(jsonConfig);

    // 4. package.json の extractorConfig
    const pkgConfig = await this.loadFromPackageJson(projectRoot);
    if (pkgConfig) configs.push(pkgConfig);

    // 5. デフォルト値
    configs.push(DEFAULT_EXTRACTOR_CONFIG);

    // マージ（先頭が優先）
    return this.mergeConfigs(configs);
  }

  private async loadFile(path: string): Promise<ExtractorConfig | null> {
    const file = Bun.file(path);
    if (!(await file.exists())) return null;

    const content = await file.text();

    if (path.endsWith('.yaml') || path.endsWith('.yml')) {
      return parseYaml(content) as ExtractorConfig;
    }
    return JSON.parse(content) as ExtractorConfig;
  }

  private async loadFromPackageJson(
    projectRoot: string
  ): Promise<ExtractorConfig | null> {
    const pkgPath = `${projectRoot}/package.json`;
    const file = Bun.file(pkgPath);
    if (!(await file.exists())) return null;

    const pkg = JSON.parse(await file.text());
    return pkg.extractorConfig ?? null;
  }

  private mergeConfigs(configs: ExtractorConfig[]): ExtractorConfig {
    // 深いマージを実行
    // 配列は連結ではなく上書き
    return configs.reduceRight((acc, config) =>
      this.deepMerge(acc, config)
    );
  }

  private deepMerge(
    base: ExtractorConfig,
    override: ExtractorConfig
  ): ExtractorConfig {
    // 実装省略 - 再帰的にマージ
  }
}
```

---

## CLI引数との統合

### 新規CLI引数

| 引数 | 短縮形 | 説明 |
|------|--------|------|
| `--config <path>` | `-c` | 設定ファイルパスを指定 |

### 既存CLI引数との関係

CLI引数は設定ファイルより優先される:

```bash
# 設定ファイルで extractResponses: false でも、CLIで上書き
endpoint-extractor --extract-responses --config ./custom.yaml
```

---

## AuthGuard継承の自動検出

設定ファイルの `authGuards` に明示的に指定されていないガードでも、`AuthGuard`を継承している場合は自動的に認証ガードとして検出する。

### 検出ロジック

```typescript
// src/extractors/nestjs/guardAnalyzer.ts

import { ClassDeclaration, Project } from 'ts-morph';

export class GuardAnalyzer {
  private authGuardCache = new Map<string, boolean>();

  /**
   * ガードが認証ガードかどうかを判定
   */
  isAuthGuard(
    guardName: string,
    guardClass: ClassDeclaration | null,
    config: NestJSAuthConfigFile,
  ): AuthGuardResult {
    // 1. 除外リストに含まれている場合
    if (config.excludeGuards?.includes(guardName)) {
      return { isAuth: false, confidence: 'high', reason: 'excluded' };
    }

    // 2. 明示的に認証ガードとして指定されている場合
    if (config.authGuards?.includes(guardName)) {
      return { isAuth: true, confidence: 'high', reason: 'config' };
    }

    // 3. パターンマッチ
    for (const pattern of config.guardPatterns ?? []) {
      if (new RegExp(pattern).test(guardName)) {
        return { isAuth: true, confidence: 'medium', reason: 'pattern' };
      }
    }

    // 4. AuthGuard継承チェック（クラス定義がある場合）
    if (guardClass) {
      const inheritsAuthGuard = this.checkAuthGuardInheritance(guardClass);
      if (inheritsAuthGuard) {
        return { isAuth: true, confidence: 'high', reason: 'inheritance' };
      }
    }

    // 5. 判定不能
    return { isAuth: false, confidence: 'low', reason: 'unknown' };
  }

  /**
   * AuthGuard継承をチェック
   */
  private checkAuthGuardInheritance(guardClass: ClassDeclaration): boolean {
    const guardName = guardClass.getName();
    if (!guardName) return false;

    // キャッシュ確認
    if (this.authGuardCache.has(guardName)) {
      return this.authGuardCache.get(guardName)!;
    }

    // 継承チェーン解析
    const result = this.analyzeInheritanceChain(guardClass);
    this.authGuardCache.set(guardName, result);
    return result;
  }

  private analyzeInheritanceChain(guardClass: ClassDeclaration): boolean {
    // extends句を取得
    const extendsExpr = guardClass.getExtends();
    if (!extendsExpr) return false;

    const extendsText = extendsExpr.getText();

    // AuthGuard('xxx') パターン
    if (extendsText.startsWith('AuthGuard(')) {
      return true;
    }

    // AuthGuard を直接継承
    if (extendsText === 'AuthGuard') {
      return true;
    }

    // 間接継承をチェック（親クラスを解析）
    const baseType = extendsExpr.getType();
    const baseSymbol = baseType.getSymbol();
    if (!baseSymbol) return false;

    const baseDeclarations = baseSymbol.getDeclarations();
    for (const decl of baseDeclarations) {
      if (decl instanceof ClassDeclaration) {
        // 再帰的にチェック
        return this.analyzeInheritanceChain(decl);
      }
    }

    return false;
  }
}

/**
 * 認証ガード判定結果
 */
export type AuthGuardResult = {
  readonly isAuth: boolean;
  readonly confidence: 'high' | 'medium' | 'low';
  readonly reason: 'config' | 'pattern' | 'inheritance' | 'excluded' | 'unknown';
};
```

---

## 認証判定の出力形式

### EndpointInfo拡張

```typescript
export type EndpointAuth = {
  /** 認証が必要か */
  readonly required: boolean | 'unknown';
  /** 判定の確信度 */
  readonly confidence: 'high' | 'medium' | 'low';
  /** 検出されたガード情報 */
  readonly guards: readonly DetectedGuard[];
};

export type DetectedGuard = {
  /** ガード名 */
  readonly name: string;
  /** 適用レベル */
  readonly level: 'class' | 'method' | 'global';
  /** 認証ガードか */
  readonly isAuthGuard: boolean;
  /** 判定理由 */
  readonly reason: 'config' | 'pattern' | 'inheritance' | 'excluded' | 'unknown';
};
```

### YAML出力例

```yaml
routes:
  - path: /projects/:projectId/organizations
    method: GET
    auth:
      required: true
      confidence: high
      guards:
        - name: JwtAuthGuard
          level: class
          isAuthGuard: true
          reason: inheritance  # AuthGuard継承を検出
        - name: CanViewProjectOnlyMyMedicalTeamGuard
          level: method
          isAuthGuard: false
          reason: unknown  # 認証ガードではないと判定
```

---

## ファイル構成（追加）

| ファイル | 内容 |
|----------|------|
| `src/types/config.ts` | 設定ファイル型定義 |
| `src/config/defaults.ts` | デフォルト設定値 |
| `src/config/loader.ts` | 設定ファイル読み込み |
| `src/extractors/nestjs/guardAnalyzer.ts` | ガード解析・継承チェック |
