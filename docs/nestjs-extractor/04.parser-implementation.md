# パーサー実装設計: NestJS エンドポイント抽出

Updated: 2025/12/30 22:20

## 目的

NestJSのデコレーターベースルーティングをAST解析し、EndpointInfo形式で出力する。

---

## ConfigLoader

### ファイル: `src/config/loader.ts`

設定ファイルの読み込みを担当。

```typescript
import { parse as parseYaml } from 'yaml';
import type { ExtractorConfig } from '../types/config';
import { DEFAULT_EXTRACTOR_CONFIG } from './defaults';

export class ConfigLoader {
  /**
   * 設定を読み込む
   */
  async load(
    projectRoot: string,
    cliConfigPath?: string,
  ): Promise<ExtractorConfig> {
    const configs: ExtractorConfig[] = [];

    // 1. CLI指定の設定ファイル
    if (cliConfigPath) {
      const config = await this.loadFile(cliConfigPath);
      if (config) configs.push(config);
    }

    // 2. extractor.config.yaml
    const yamlConfig = await this.loadFile(
      `${projectRoot}/extractor.config.yaml`
    );
    if (yamlConfig) configs.push(yamlConfig);

    // 3. extractor.config.json
    const jsonConfig = await this.loadFile(
      `${projectRoot}/extractor.config.json`
    );
    if (jsonConfig) configs.push(jsonConfig);

    // 4. package.json の extractorConfig
    const pkgConfig = await this.loadFromPackageJson(projectRoot);
    if (pkgConfig) configs.push(pkgConfig);

    // 5. デフォルト値
    configs.push(DEFAULT_EXTRACTOR_CONFIG);

    // マージ（先頭が優先）
    return this.mergeConfigs(configs);
  }

  private async loadFile(filePath: string): Promise<ExtractorConfig | null> {
    const file = Bun.file(filePath);
    if (!(await file.exists())) return null;

    const content = await file.text();

    if (filePath.endsWith('.yaml') || filePath.endsWith('.yml')) {
      return parseYaml(content) as ExtractorConfig;
    }
    return JSON.parse(content) as ExtractorConfig;
  }

  private async loadFromPackageJson(
    projectRoot: string
  ): Promise<ExtractorConfig | null> {
    const pkgPath = `${projectRoot}/package.json`;
    const file = Bun.file(pkgPath);
    if (!(await file.exists())) return null;

    const pkg = JSON.parse(await file.text());
    return pkg.extractorConfig ?? null;
  }

  private mergeConfigs(configs: ExtractorConfig[]): ExtractorConfig {
    return configs.reduceRight((acc, config) =>
      this.deepMerge(acc, config)
    );
  }

  private deepMerge<T extends object>(base: T, override: T): T {
    const result = { ...base } as Record<string, unknown>;

    for (const key of Object.keys(override)) {
      const baseValue = result[key];
      const overrideValue = (override as Record<string, unknown>)[key];

      if (
        typeof baseValue === 'object' &&
        baseValue !== null &&
        !Array.isArray(baseValue) &&
        typeof overrideValue === 'object' &&
        overrideValue !== null &&
        !Array.isArray(overrideValue)
      ) {
        result[key] = this.deepMerge(
          baseValue as object,
          overrideValue as object
        );
      } else if (overrideValue !== undefined) {
        result[key] = overrideValue;
      }
    }

    return result as T;
  }
}
```

### ファイル: `src/config/defaults.ts`

デフォルト設定値。

```typescript
import type { ExtractorConfig } from '../types/config';

export const DEFAULT_EXTRACTOR_CONFIG: ExtractorConfig = {
  common: {
    outputFormat: 'yaml',
    extractResponses: false,
    responseDepth: 2,
  },
  nestjs: {
    auth: {
      guardPatterns: [
        '.*AuthGuard$',
        '.*JwtGuard$',
        '.*SessionGuard$',
        '.*TokenGuard$',
      ],
      authGuards: [],
      excludeGuards: [
        'ThrottlerGuard',
        'RateLimitGuard',
      ],
      publicDecorators: [
        'Public',
        'SkipAuth',
        'AllowAnonymous',
      ],
      publicMetadataKeys: [
        'isPublic',
        'IS_PUBLIC_KEY',
        'skipAuth',
      ],
    },
    params: {
      customDecorators: [],
    },
  },
  fastify: {
    auth: {
      middlewareNames: [
        'authenticate',
        'verifyJWT',
        'requireAuth',
      ],
    },
  },
};
```

---

## GuardAnalyzer

### ファイル: `src/extractors/nestjs/guardAnalyzer.ts`

ガードの解析と認証ガード判定を担当。`AuthGuard`継承を自動検出する。

```typescript
import { ClassDeclaration, Project, SourceFile } from 'ts-morph';
import type { AuthGuardResult, NestJSAuthConfigFile } from '../../types';

export class GuardAnalyzer {
  private readonly authGuardCache = new Map<string, boolean>();
  private readonly project: Project;

  constructor(project: Project) {
    this.project = project;
  }

  /**
   * ガードが認証ガードかどうかを判定
   */
  isAuthGuard(
    guardName: string,
    config: NestJSAuthConfigFile,
  ): AuthGuardResult {
    // 1. 除外リストに含まれている場合
    if (config.excludeGuards?.includes(guardName)) {
      return { isAuth: false, confidence: 'high', reason: 'excluded' };
    }

    // 2. 明示的に認証ガードとして指定されている場合
    if (config.authGuards?.includes(guardName)) {
      return { isAuth: true, confidence: 'high', reason: 'config' };
    }

    // 3. パターンマッチ
    for (const pattern of config.guardPatterns ?? []) {
      if (new RegExp(pattern).test(guardName)) {
        return { isAuth: true, confidence: 'medium', reason: 'pattern' };
      }
    }

    // 4. AuthGuard継承チェック
    const guardClass = this.findGuardClass(guardName);
    if (guardClass) {
      const inheritsAuthGuard = this.checkAuthGuardInheritance(guardClass);
      if (inheritsAuthGuard) {
        return { isAuth: true, confidence: 'high', reason: 'inheritance' };
      }
    }

    // 5. 判定不能
    return { isAuth: false, confidence: 'low', reason: 'unknown' };
  }

  /**
   * プロジェクト内からガードクラスを探す
   */
  private findGuardClass(guardName: string): ClassDeclaration | null {
    const sourceFiles = this.project.getSourceFiles();

    for (const sourceFile of sourceFiles) {
      const classes = sourceFile.getClasses();
      for (const classDecl of classes) {
        if (classDecl.getName() === guardName) {
          return classDecl;
        }
      }
    }

    return null;
  }

  /**
   * AuthGuard継承をチェック
   */
  private checkAuthGuardInheritance(guardClass: ClassDeclaration): boolean {
    const guardName = guardClass.getName();
    if (!guardName) return false;

    // キャッシュ確認
    if (this.authGuardCache.has(guardName)) {
      return this.authGuardCache.get(guardName)!;
    }

    // 継承チェーン解析
    const result = this.analyzeInheritanceChain(guardClass);
    this.authGuardCache.set(guardName, result);
    return result;
  }

  /**
   * 継承チェーンを解析
   */
  private analyzeInheritanceChain(guardClass: ClassDeclaration): boolean {
    // extends句を取得
    const extendsExpr = guardClass.getExtends();
    if (!extendsExpr) return false;

    const extendsText = extendsExpr.getText();

    // AuthGuard('xxx') パターン
    if (extendsText.startsWith('AuthGuard(')) {
      return true;
    }

    // AuthGuard を直接継承
    if (extendsText === 'AuthGuard') {
      return true;
    }

    // 間接継承をチェック（親クラスを解析）
    const baseClassName = this.extractClassName(extendsText);
    if (!baseClassName) return false;

    const baseClass = this.findGuardClass(baseClassName);
    if (baseClass) {
      // 再帰的にチェック（キャッシュ経由）
      return this.checkAuthGuardInheritance(baseClass);
    }

    return false;
  }

  /**
   * 継承式からクラス名を抽出
   */
  private extractClassName(extendsText: string): string | null {
    // AuthGuard('jwt') -> null (既にチェック済み)
    if (extendsText.includes('(')) {
      return null;
    }
    // JwtAuthGuard -> JwtAuthGuard
    return extendsText.trim();
  }
}
```

---

## DecoratorParser

### ファイル: `src/extractors/nestjs/decoratorParser.ts`

デコレーターの解析を担当するクラス。

```typescript
import { MethodDeclaration, ClassDeclaration, Decorator, Node } from 'ts-morph';
import type {
  MethodDecoratorInfo,
  ParamDecoratorInfo,
  GuardDecoratorInfo,
  MetadataDecoratorInfo,
  MethodDecoratorType,
  ParamDecoratorType,
} from '../../types/nestjs';

const HTTP_METHOD_DECORATORS: readonly MethodDecoratorType[] = [
  'Get', 'Post', 'Put', 'Delete', 'Patch', 'Options', 'Head', 'All'
];

const PARAM_DECORATORS: readonly ParamDecoratorType[] = [
  'Param', 'Body', 'Query', 'Headers', 'Req', 'Res'
];

export class DecoratorParser {
  /**
   * メソッドからHTTPメソッドデコレーターを抽出
   */
  parseMethodDecorator(method: MethodDeclaration): MethodDecoratorInfo | null {
    const decorators = method.getDecorators();

    for (const decorator of decorators) {
      const name = decorator.getName();

      if (!HTTP_METHOD_DECORATORS.includes(name as MethodDecoratorType)) {
        continue;
      }

      const args = decorator.getArguments();
      const path = args.length > 0 ? this.extractStringValue(args[0]) : '';

      return {
        type: name as MethodDecoratorType,
        path,
        lineNumber: decorator.getStartLineNumber(),
      };
    }

    return null;
  }

  /**
   * メソッドからパラメーターデコレーターを抽出
   */
  parseParamDecorators(method: MethodDeclaration): readonly ParamDecoratorInfo[] {
    const params = method.getParameters();
    const results: ParamDecoratorInfo[] = [];

    for (const param of params) {
      const decorators = param.getDecorators();

      for (const decorator of decorators) {
        const name = decorator.getName();

        if (!PARAM_DECORATORS.includes(name as ParamDecoratorType)) {
          continue;
        }

        const args = decorator.getArguments();
        const argName = args.length > 0 ? this.extractStringValue(args[0]) : undefined;

        results.push({
          type: name as ParamDecoratorType,
          argName,
          paramName: param.getName(),
          paramType: param.getType().getText(),
          required: !param.isOptional() && !param.hasQuestionToken(),
        });
      }
    }

    return results;
  }

  /**
   * メソッドまたはクラスから@UseGuardsを抽出
   */
  parseGuardDecorators(
    node: MethodDeclaration | ClassDeclaration,
    level: 'method' | 'class' = 'method'
  ): readonly GuardDecoratorInfo[] {
    const decorators = node.getDecorators();
    const results: GuardDecoratorInfo[] = [];

    for (const decorator of decorators) {
      if (decorator.getName() !== 'UseGuards') {
        continue;
      }

      const args = decorator.getArguments();
      const guards = args.map(arg => this.extractIdentifierName(arg));

      results.push({
        guards: guards.filter((g): g is string => g !== null),
        level,
        lineNumber: decorator.getStartLineNumber(),
      });
    }

    return results;
  }

  /**
   * カスタムメタデータデコレーターを抽出
   */
  parseMetadataDecorators(
    node: MethodDeclaration | ClassDeclaration,
    decoratorNames: readonly string[]
  ): readonly MetadataDecoratorInfo[] {
    const decorators = node.getDecorators();
    const results: MetadataDecoratorInfo[] = [];

    for (const decorator of decorators) {
      const name = decorator.getName();

      if (!decoratorNames.includes(name)) {
        continue;
      }

      const args = decorator.getArguments();
      const value = this.extractDecoratorValue(args);

      results.push({
        name,
        key: this.inferMetadataKey(name),
        value,
        lineNumber: decorator.getStartLineNumber(),
      });
    }

    return results;
  }

  /**
   * @Controller('path')からパスを抽出
   */
  parseControllerDecorator(classDecl: ClassDeclaration): string {
    const decorator = classDecl.getDecorator('Controller');
    if (!decorator) {
      return '';
    }

    const args = decorator.getArguments();
    if (args.length === 0) {
      return '';
    }

    return this.extractStringValue(args[0]);
  }

  // --- Private Methods ---

  private extractStringValue(node: Node): string {
    if (Node.isStringLiteral(node)) {
      return node.getLiteralValue();
    }
    return node.getText().replace(/['"]/g, '');
  }

  private extractIdentifierName(node: Node): string | null {
    if (Node.isIdentifier(node)) {
      return node.getText();
    }
    if (Node.isCallExpression(node)) {
      const expr = node.getExpression();
      if (Node.isIdentifier(expr)) {
        return expr.getText();
      }
    }
    return null;
  }

  private extractDecoratorValue(args: Node[]): unknown {
    if (args.length === 0) {
      return true; // @Public() のような引数なしデコレーター
    }

    if (args.length === 1) {
      return this.nodeToValue(args[0]);
    }

    return args.map(arg => this.nodeToValue(arg));
  }

  private nodeToValue(node: Node): unknown {
    if (Node.isStringLiteral(node)) {
      return node.getLiteralValue();
    }
    if (Node.isNumericLiteral(node)) {
      return node.getLiteralValue();
    }
    if (Node.isTrueLiteral(node)) {
      return true;
    }
    if (Node.isFalseLiteral(node)) {
      return false;
    }
    if (Node.isArrayLiteralExpression(node)) {
      return node.getElements().map(el => this.nodeToValue(el));
    }
    return node.getText();
  }

  private inferMetadataKey(decoratorName: string): string {
    const keyMap: Record<string, string> = {
      Public: 'isPublic',
      SkipAuth: 'skipAuth',
      Roles: 'roles',
      Permissions: 'permissions',
    };
    return keyMap[decoratorName] ?? decoratorName.toLowerCase();
  }
}
```

---

## ControllerParser

### ファイル: `src/extractors/nestjs/controllerParser.ts`

コントローラークラスの解析を担当。

```typescript
import { SourceFile, ClassDeclaration } from 'ts-morph';
import type { ControllerInfo, ControllerMethodInfo, EndpointInfo } from '../../types';
import { DecoratorParser } from './decoratorParser';
import { HTTP_METHOD_MAP } from '../../types/nestjs';

export class ControllerParser {
  private readonly decoratorParser: DecoratorParser;
  private readonly publicDecorators: readonly string[];

  constructor(publicDecorators: readonly string[] = ['Public', 'SkipAuth']) {
    this.decoratorParser = new DecoratorParser();
    this.publicDecorators = publicDecorators;
  }

  /**
   * ソースファイルからコントローラー情報を抽出
   */
  parseController(sourceFile: SourceFile): ControllerInfo | null {
    const classes = sourceFile.getClasses();

    for (const classDecl of classes) {
      if (!classDecl.getDecorator('Controller')) {
        continue;
      }

      return this.parseControllerClass(classDecl, sourceFile.getFilePath());
    }

    return null;
  }

  /**
   * コントローラークラスを解析
   */
  private parseControllerClass(
    classDecl: ClassDeclaration,
    sourceFilePath: string
  ): ControllerInfo {
    const basePath = this.decoratorParser.parseControllerDecorator(classDecl);
    const classGuards = this.decoratorParser.parseGuardDecorators(classDecl, 'class');
    const classMetadata = this.decoratorParser.parseMetadataDecorators(
      classDecl,
      this.publicDecorators
    );

    const methods = this.parseMethods(classDecl);

    return {
      name: classDecl.getName() ?? 'AnonymousController',
      basePath,
      classGuards,
      classMetadata,
      methods,
      sourceFile: sourceFilePath,
      lineNumber: classDecl.getStartLineNumber(),
    };
  }

  /**
   * コントローラーのメソッドを解析
   */
  private parseMethods(classDecl: ClassDeclaration): readonly ControllerMethodInfo[] {
    const methods = classDecl.getMethods();
    const results: ControllerMethodInfo[] = [];

    for (const method of methods) {
      const httpMethod = this.decoratorParser.parseMethodDecorator(method);
      if (!httpMethod) {
        continue; // HTTPメソッドデコレーターがないメソッドはスキップ
      }

      results.push({
        name: method.getName(),
        httpMethod,
        params: this.decoratorParser.parseParamDecorators(method),
        guards: this.decoratorParser.parseGuardDecorators(method, 'method'),
        metadata: this.decoratorParser.parseMetadataDecorators(method, this.publicDecorators),
        lineNumber: method.getStartLineNumber(),
      });
    }

    return results;
  }

  /**
   * EndpointInfo形式に変換
   */
  extractEndpoints(
    controller: ControllerInfo,
    globalGuards: readonly string[],
    authDetector: AuthDetector
  ): readonly EndpointInfo[] {
    return controller.methods.map(method => {
      const fullPath = this.joinPaths(controller.basePath, method.httpMethod.path);

      return {
        path: fullPath,
        method: HTTP_METHOD_MAP[method.httpMethod.type],
        pathParams: this.extractPathParams(method.params),
        queryParams: this.extractQueryParams(method.params),
        bodyParams: this.extractBodyParams(method.params),
        auth: authDetector.detectAuth(controller, method, globalGuards),
        sourceFile: controller.sourceFile,
        lineNumber: method.lineNumber,
      };
    });
  }

  // --- Private Methods ---

  private joinPaths(basePath: string, methodPath: string): string {
    const base = basePath.startsWith('/') ? basePath : `/${basePath}`;
    if (!methodPath) {
      return base;
    }
    const method = methodPath.startsWith('/') ? methodPath : `/${methodPath}`;
    return `${base}${method}`.replace(/\/+/g, '/');
  }

  private extractPathParams(params: readonly ParamDecoratorInfo[]): readonly ParamInfo[] {
    return params
      .filter(p => p.type === 'Param')
      .map(p => ({
        name: p.argName ?? p.paramName,
        type: p.paramType,
        required: p.required,
      }));
  }

  private extractQueryParams(params: readonly ParamDecoratorInfo[]): readonly ParamInfo[] {
    return params
      .filter(p => p.type === 'Query')
      .map(p => ({
        name: p.argName ?? p.paramName,
        type: p.paramType,
        required: p.required,
      }));
  }

  private extractBodyParams(params: readonly ParamDecoratorInfo[]): readonly ParamInfo[] {
    // @Body()の型からプロパティを抽出
    const bodyParam = params.find(p => p.type === 'Body');
    if (!bodyParam) {
      return [];
    }

    // DTOの型情報を解析してParamInfo[]に変換
    // TypeExtractorを使用
    return [];
  }
}
```

---

## AuthDetector

### ファイル: `src/extractors/nestjs/authDetector.ts`

認証要否の判定を担当。GuardAnalyzerと連携して認証ガードを判定する。

```typescript
import type {
  ControllerInfo,
  ControllerMethodInfo,
  EndpointAuth,
  DetectedGuard,
  NestJSAuthConfigFile,
} from '../../types';
import { GuardAnalyzer } from './guardAnalyzer';

export class NestJSAuthDetector {
  constructor(
    private readonly config: NestJSAuthConfigFile,
    private readonly guardAnalyzer: GuardAnalyzer,
  ) {}

  /**
   * メソッドの認証要否を判定
   */
  detectAuth(
    controller: ControllerInfo,
    method: ControllerMethodInfo,
    globalGuards: readonly string[]
  ): EndpointAuth {
    // 1. @Publicチェック（最優先）
    if (this.isPublicRoute(controller, method)) {
      return {
        required: false,
        confidence: 'high',
        guards: [],
      };
    }

    // 2. ガード収集と判定
    const detectedGuards = this.collectAndAnalyzeGuards(
      controller,
      method,
      globalGuards
    );

    // 3. 認証ガードの存在チェック
    const authGuards = detectedGuards.filter(g => g.isAuthGuard);
    const hasAuthGuard = authGuards.length > 0;

    // 4. 確信度を計算
    const confidence = this.calculateConfidence(detectedGuards);

    return {
      required: hasAuthGuard ? true : (detectedGuards.length === 0 ? 'unknown' : false),
      confidence,
      guards: detectedGuards,
    };
  }

  /**
   * @Publicデコレーターの有無をチェック
   */
  private isPublicRoute(
    controller: ControllerInfo,
    method: ControllerMethodInfo
  ): boolean {
    // メソッドレベルのメタデータをチェック
    for (const meta of method.metadata) {
      if (this.config.publicDecorators?.includes(meta.name)) {
        return true;
      }
      if (this.config.publicMetadataKeys?.includes(meta.key)) {
        return true;
      }
    }

    // クラスレベルのメタデータをチェック
    for (const meta of controller.classMetadata) {
      if (this.config.publicDecorators?.includes(meta.name)) {
        return true;
      }
    }

    return false;
  }

  /**
   * ガードを収集し、各ガードが認証ガードかを判定
   */
  private collectAndAnalyzeGuards(
    controller: ControllerInfo,
    method: ControllerMethodInfo,
    globalGuards: readonly string[]
  ): readonly DetectedGuard[] {
    const results: DetectedGuard[] = [];

    // グローバルガード
    for (const guardName of globalGuards) {
      const result = this.guardAnalyzer.isAuthGuard(guardName, this.config);
      results.push({
        name: guardName,
        level: 'global',
        isAuthGuard: result.isAuth,
        reason: result.reason,
      });
    }

    // クラスレベルのガード
    for (const guardInfo of controller.classGuards) {
      for (const guardName of guardInfo.guards) {
        const result = this.guardAnalyzer.isAuthGuard(guardName, this.config);
        results.push({
          name: guardName,
          level: 'class',
          isAuthGuard: result.isAuth,
          reason: result.reason,
        });
      }
    }

    // メソッドレベルのガード
    for (const guardInfo of method.guards) {
      for (const guardName of guardInfo.guards) {
        const result = this.guardAnalyzer.isAuthGuard(guardName, this.config);
        results.push({
          name: guardName,
          level: 'method',
          isAuthGuard: result.isAuth,
          reason: result.reason,
        });
      }
    }

    return results;
  }

  /**
   * 判定の確信度を計算
   */
  private calculateConfidence(
    guards: readonly DetectedGuard[]
  ): 'high' | 'medium' | 'low' {
    if (guards.length === 0) {
      return 'low';
    }

    const hasUnknown = guards.some(g => g.reason === 'unknown');
    const allHighConfidence = guards.every(
      g => g.reason === 'config' || g.reason === 'inheritance' || g.reason === 'excluded'
    );

    if (allHighConfidence) {
      return 'high';
    }
    if (hasUnknown) {
      return 'low';
    }
    return 'medium';
  }
}
```

---

## ModuleParser

### ファイル: `src/extractors/nestjs/moduleParser.ts`

app.module.tsの解析を担当。

```typescript
import { SourceFile, Node, ObjectLiteralExpression } from 'ts-morph';
import type { ModuleInfo, ControllerRegistration } from '../../types/nestjs';
import * as path from 'path';

export class ModuleParser {
  /**
   * モジュールファイルを解析
   */
  parseModule(sourceFile: SourceFile): ModuleInfo {
    const classes = sourceFile.getClasses();

    for (const classDecl of classes) {
      const moduleDecorator = classDecl.getDecorator('Module');
      if (!moduleDecorator) {
        continue;
      }

      const args = moduleDecorator.getArguments();
      if (args.length === 0 || !Node.isObjectLiteralExpression(args[0])) {
        continue;
      }

      const config = args[0] as ObjectLiteralExpression;

      return {
        name: classDecl.getName() ?? 'AppModule',
        controllers: this.extractControllers(config, sourceFile),
        globalGuards: this.extractGlobalGuards(config),
        sourceFile: sourceFile.getFilePath(),
      };
    }

    return {
      name: 'Unknown',
      controllers: [],
      globalGuards: [],
      sourceFile: sourceFile.getFilePath(),
    };
  }

  /**
   * controllersプロパティからコントローラー一覧を抽出
   */
  private extractControllers(
    config: ObjectLiteralExpression,
    sourceFile: SourceFile
  ): readonly ControllerRegistration[] {
    const controllersProp = config.getProperty('controllers');
    if (!controllersProp || !Node.isPropertyAssignment(controllersProp)) {
      return [];
    }

    const initializer = controllersProp.getInitializer();
    if (!initializer || !Node.isArrayLiteralExpression(initializer)) {
      return [];
    }

    const results: ControllerRegistration[] = [];
    const elements = initializer.getElements();

    for (const element of elements) {
      if (!Node.isIdentifier(element)) {
        continue;
      }

      const name = element.getText();
      const importPath = this.resolveImportPath(sourceFile, name);

      results.push({
        name,
        importPath,
        resolvedPath: this.resolveFilePath(sourceFile.getFilePath(), importPath),
      });
    }

    return results;
  }

  /**
   * APP_GUARDからグローバルガードを抽出
   */
  private extractGlobalGuards(config: ObjectLiteralExpression): readonly string[] {
    const providersProp = config.getProperty('providers');
    if (!providersProp || !Node.isPropertyAssignment(providersProp)) {
      return [];
    }

    const initializer = providersProp.getInitializer();
    if (!initializer || !Node.isArrayLiteralExpression(initializer)) {
      return [];
    }

    const guards: string[] = [];
    const elements = initializer.getElements();

    for (const element of elements) {
      if (!Node.isObjectLiteralExpression(element)) {
        continue;
      }

      const provideProp = element.getProperty('provide');
      const useClassProp = element.getProperty('useClass');

      if (!provideProp || !useClassProp) {
        continue;
      }

      // provide: APP_GUARD のチェック
      const provideInit = Node.isPropertyAssignment(provideProp)
        ? provideProp.getInitializer()
        : null;

      if (!provideInit || provideInit.getText() !== 'APP_GUARD') {
        continue;
      }

      // useClass の値を取得
      const useClassInit = Node.isPropertyAssignment(useClassProp)
        ? useClassProp.getInitializer()
        : null;

      if (useClassInit && Node.isIdentifier(useClassInit)) {
        guards.push(useClassInit.getText());
      }
    }

    return guards;
  }

  // --- Private Methods ---

  private resolveImportPath(sourceFile: SourceFile, identifier: string): string {
    const imports = sourceFile.getImportDeclarations();

    for (const importDecl of imports) {
      const namedImports = importDecl.getNamedImports();
      for (const namedImport of namedImports) {
        if (namedImport.getName() === identifier) {
          return importDecl.getModuleSpecifierValue();
        }
      }
    }

    return '';
  }

  private resolveFilePath(moduleFilePath: string, importPath: string): string {
    if (!importPath.startsWith('.')) {
      return importPath; // node_modulesからのインポート
    }

    const dir = path.dirname(moduleFilePath);
    let resolved = path.resolve(dir, importPath);

    // .ts拡張子を追加
    if (!resolved.endsWith('.ts')) {
      resolved += '.ts';
    }

    return resolved;
  }
}
```

---

## 統合

### ファイル: `src/extractors/nestjs/index.ts`

ConfigLoader、GuardAnalyzer、AuthDetectorを統合。

```typescript
import type { EndpointExtractor } from '../types';
import type {
  ExtractorOptions,
  ExtractedEndpoints,
  FrameworkType,
} from '../../types';
import { Project } from 'ts-morph';
import { ConfigLoader } from '../../config/loader';
import { ModuleParser } from './moduleParser';
import { ControllerParser } from './controllerParser';
import { GuardAnalyzer } from './guardAnalyzer';
import { NestJSAuthDetector } from './authDetector';
import * as path from 'path';

export class NestJSExtractor implements EndpointExtractor {
  readonly framework: FrameworkType = 'nestjs';
  private readonly configLoader = new ConfigLoader();

  async extract(options: ExtractorOptions): Promise<ExtractedEndpoints> {
    const {
      projectRoot,
      entryFilePath = 'src/app.module.ts',
      tsconfigPath,
      configPath,
      verbose = false,
    } = options;

    // 1. 設定ファイルを読み込み
    const config = await this.configLoader.load(projectRoot, configPath);
    const nestjsConfig = config.nestjs?.auth ?? {};

    const fullEntryPath = path.join(projectRoot, entryFilePath);
    const fullTsconfigPath = tsconfigPath
      ? path.join(projectRoot, tsconfigPath)
      : path.join(projectRoot, 'tsconfig.json');

    const project = new Project({ tsConfigFilePath: fullTsconfigPath });

    // 2. app.module.tsを解析
    const moduleParser = new ModuleParser();
    const moduleFile = project.getSourceFile(fullEntryPath);
    if (!moduleFile) {
      throw new Error(`Module file not found: ${fullEntryPath}`);
    }

    const moduleInfo = moduleParser.parseModule(moduleFile);

    if (verbose) {
      console.log(`[NestJSExtractor] Found ${moduleInfo.controllers.length} controllers`);
      console.log(`[NestJSExtractor] Global guards: ${moduleInfo.globalGuards.join(', ')}`);
    }

    // 3. GuardAnalyzerとAuthDetectorを初期化
    const guardAnalyzer = new GuardAnalyzer(project);
    const authDetector = new NestJSAuthDetector(nestjsConfig, guardAnalyzer);

    // 4. 各コントローラーを解析
    const controllerParser = new ControllerParser(
      nestjsConfig.publicDecorators ?? ['Public', 'SkipAuth']
    );

    const routes = [];
    for (const registration of moduleInfo.controllers) {
      const controllerFile = project.getSourceFile(registration.resolvedPath);
      if (!controllerFile) {
        if (verbose) {
          console.log(`[NestJSExtractor] Controller file not found: ${registration.resolvedPath}`);
        }
        continue;
      }

      const controller = controllerParser.parseController(controllerFile);
      if (!controller) {
        continue;
      }

      const endpoints = controllerParser.extractEndpoints(
        controller,
        moduleInfo.globalGuards,
        authDetector
      );

      routes.push({
        prefix: `/${controller.basePath}`,
        endpoints,
      });
    }

    // 5. 統計計算
    const allEndpoints = routes.flatMap(r => r.endpoints);
    const authRequiredCount = allEndpoints.filter(e => e.auth.required === true).length;
    const unknownCount = allEndpoints.filter(e => e.auth.required === 'unknown').length;
    const publicCount = allEndpoints.filter(e => e.auth.required === false).length;

    return {
      framework: 'nestjs',
      projectRoot,
      routes,
      extractedAt: new Date().toISOString(),
      authRequiredCount,
      publicCount,
      unknownCount,
    };
  }

  async canHandle(projectRoot: string): Promise<boolean> {
    try {
      const packageJsonPath = `${projectRoot}/package.json`;
      const file = Bun.file(packageJsonPath);
      const content = await file.text();
      const packageJson = JSON.parse(content);

      const allDeps = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies,
      };

      return '@nestjs/common' in allDeps;
    } catch {
      return false;
    }
  }
}
```

---

## CLI対応

### ファイル: `index.ts` への変更

```typescript
// インポート追加
import { NestJSExtractor } from './src/extractors/nestjs';

// フレームワーク自動検出
async function detectFramework(projectRoot: string): Promise<FrameworkType> {
  const nestExtractor = new NestJSExtractor();
  if (await nestExtractor.canHandle(projectRoot)) {
    return 'nestjs';
  }

  const fastifyExtractor = new FastifyExtractor();
  if (await fastifyExtractor.canHandle(projectRoot)) {
    return 'fastify';
  }

  throw new Error('No supported framework detected');
}

// Extractor選択
function createExtractor(framework: FrameworkType): EndpointExtractor {
  switch (framework) {
    case 'nestjs':
      return new NestJSExtractor();
    case 'fastify':
      return new FastifyExtractor();
    default:
      throw new Error(`Unsupported framework: ${framework}`);
  }
}
```
