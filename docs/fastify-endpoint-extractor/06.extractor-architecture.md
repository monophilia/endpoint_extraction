# Extractorアーキテクチャ設計

Updated: 2025/12/29 23:00

## 概要

マルチフレームワーク対応のためのプラグインアーキテクチャ設計。
Fastify, NestJS, Expressなど異なるフレームワークに対応するための拡張可能な構造を定義する。

---

## 設計原則

### 1. 単一責任原則

各コンポーネントは1つの責任のみを持つ:

| コンポーネント | 責任 |
|--------------|------|
| FrameworkDetector | フレームワークの自動検出 |
| ExtractorFactory | 適切なExtractorの生成 |
| EndpointExtractor | エンドポイントの抽出（フレームワーク固有） |
| TypeExtractor | TypeScript型の解析（共通） |
| YamlGenerator | YAML出力の生成（共通） |

### 2. 開放閉鎖原則

- 新しいフレームワーク対応は既存コードを変更せずに追加可能
- `EndpointExtractor`インターフェースを実装するだけで拡張可能

### 3. 依存性逆転原則

- 上位モジュールは下位モジュールに依存しない
- 両者とも抽象（インターフェース）に依存する

---

## ディレクトリ構成

```
src/
├── types/                      # 共通型定義
│   ├── index.ts
│   ├── framework.ts
│   ├── auth.ts
│   ├── endpoint.ts
│   ├── options.ts
│   └── ...
│
├── core/                       # 共通基盤
│   ├── typeExtractor.ts        # TypeScript型解析
│   ├── frameworkDetector.ts    # フレームワーク検出
│   └── extractorFactory.ts     # Extractor生成ファクトリ
│
├── extractors/                 # フレームワーク固有実装
│   ├── types.ts                # EndpointExtractorインターフェース
│   │
│   ├── fastify/                # Fastify実装
│   │   ├── index.ts            # FastifyExtractor
│   │   ├── buildFileParser.ts
│   │   ├── routeFileParser.ts
│   │   └── authDetector.ts
│   │
│   ├── nestjs/                 # NestJS実装（将来）
│   │   ├── index.ts            # NestJSExtractor
│   │   ├── controllerParser.ts
│   │   ├── decoratorParser.ts
│   │   └── guardDetector.ts
│   │
│   └── express/                # Express実装（将来）
│       └── index.ts            # ExpressExtractor
│
├── generators/                 # 出力生成
│   └── yamlGenerator.ts
│
└── index.ts                    # CLIエントリーポイント
```

---

## FrameworkDetector {#framework-detector}

### 目的

プロジェクトのpackage.jsonを解析し、使用されているWebフレームワークを自動検出する。

### 実装

```typescript
// src/core/frameworkDetector.ts

import type { FrameworkType, FrameworkDetectionResult } from '../types';

/**
 * フレームワーク検出の優先度と依存関係パターン
 */
const FRAMEWORK_PATTERNS: ReadonlyArray<{
  framework: FrameworkType;
  dependencies: readonly string[];
  priority: number;
}> = [
  {
    framework: 'nestjs',
    dependencies: ['@nestjs/core', '@nestjs/common'],
    priority: 1, // 最優先（他のフレームワークと併用されることがある）
  },
  {
    framework: 'fastify',
    dependencies: ['fastify'],
    priority: 2,
  },
  {
    framework: 'express',
    dependencies: ['express'],
    priority: 3,
  },
];

export class FrameworkDetector {
  /**
   * package.jsonからフレームワークを検出
   */
  async detect(projectRoot: string): Promise<FrameworkDetectionResult | null> {
    const packageJsonPath = `${projectRoot}/package.json`;

    const packageJson = await this.readPackageJson(packageJsonPath);
    if (!packageJson) {
      return null;
    }

    const allDeps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies,
    };

    // 優先度順にチェック
    const sortedPatterns = [...FRAMEWORK_PATTERNS].sort(
      (a, b) => a.priority - b.priority
    );

    for (const pattern of sortedPatterns) {
      const matchedDeps = pattern.dependencies.filter(dep => dep in allDeps);

      if (matchedDeps.length > 0) {
        const confidence = matchedDeps.length / pattern.dependencies.length;

        return {
          framework: pattern.framework,
          confidence,
          reason: `Found dependencies: ${matchedDeps.join(', ')}`,
        };
      }
    }

    return null;
  }

  /**
   * 特定のフレームワークかどうか判定
   */
  async isFramework(
    projectRoot: string,
    framework: FrameworkType
  ): Promise<boolean> {
    const result = await this.detect(projectRoot);
    return result?.framework === framework;
  }

  private async readPackageJson(
    path: string
  ): Promise<{ dependencies?: Record<string, string>; devDependencies?: Record<string, string> } | null> {
    try {
      const file = Bun.file(path);
      const content = await file.text();
      return JSON.parse(content);
    } catch {
      return null;
    }
  }
}
```

---

## ExtractorFactory {#extractor-factory}

### 目的

検出されたフレームワークに応じて適切なExtractorインスタンスを生成する。

### 実装

```typescript
// src/core/extractorFactory.ts

import type { FrameworkType } from '../types';
import type { EndpointExtractor } from '../extractors/types';
import { FastifyExtractor } from '../extractors/fastify';
// import { NestJSExtractor } from '../extractors/nestjs';  // 将来
// import { ExpressExtractor } from '../extractors/express'; // 将来
import { FrameworkDetector } from './frameworkDetector';

/**
 * 登録済みExtractor
 */
const EXTRACTORS: ReadonlyMap<FrameworkType, new () => EndpointExtractor> = new Map([
  ['fastify', FastifyExtractor],
  // ['nestjs', NestJSExtractor],   // 将来追加
  // ['express', ExpressExtractor], // 将来追加
]);

export class ExtractorFactory {
  private detector: FrameworkDetector;

  constructor() {
    this.detector = new FrameworkDetector();
  }

  /**
   * フレームワークを指定してExtractorを取得
   */
  getExtractor(framework: FrameworkType): EndpointExtractor {
    const ExtractorClass = EXTRACTORS.get(framework);

    if (!ExtractorClass) {
      throw new Error(`Unsupported framework: ${framework}`);
    }

    return new ExtractorClass();
  }

  /**
   * プロジェクトから自動検出してExtractorを取得
   */
  async getExtractorForProject(projectRoot: string): Promise<EndpointExtractor> {
    const detection = await this.detector.detect(projectRoot);

    if (!detection) {
      throw new Error(
        `Could not detect framework in ${projectRoot}. ` +
        `Supported frameworks: ${[...EXTRACTORS.keys()].join(', ')}`
      );
    }

    return this.getExtractor(detection.framework);
  }

  /**
   * 対応フレームワーク一覧を取得
   */
  getSupportedFrameworks(): readonly FrameworkType[] {
    return [...EXTRACTORS.keys()];
  }

  /**
   * Extractorを登録（プラグイン追加用）
   */
  static registerExtractor(
    framework: FrameworkType,
    ExtractorClass: new () => EndpointExtractor
  ): void {
    (EXTRACTORS as Map<FrameworkType, new () => EndpointExtractor>).set(
      framework,
      ExtractorClass
    );
  }
}
```

---

## FastifyExtractor {#fastify-extractor}

### 目的

Fastifyプロジェクト固有のエンドポイント抽出ロジックをカプセル化する。

### 実装

```typescript
// src/extractors/fastify/index.ts

import type { EndpointExtractor } from '../types';
import type {
  ExtractorOptions,
  ExtractedEndpoints,
  FrameworkType,
  AuthConfig,
  DEFAULT_AUTH_CONFIG,
} from '../../types';
import { BuildFileParser } from './buildFileParser';
import { RouteFileParser } from './routeFileParser';
import { AuthDetector } from './authDetector';
import * as path from 'path';

export class FastifyExtractor implements EndpointExtractor {
  readonly framework: FrameworkType = 'fastify';

  async extract(options: ExtractorOptions): Promise<ExtractedEndpoints> {
    const {
      projectRoot,
      entryFilePath = 'src/build.ts',
      tsconfigPath,
      authConfig = DEFAULT_AUTH_CONFIG,
      verbose = false,
    } = options;

    const fullEntryPath = path.join(projectRoot, entryFilePath);
    const fullTsconfigPath = tsconfigPath
      ? path.join(projectRoot, tsconfigPath)
      : path.join(projectRoot, 'tsconfig.json');

    if (verbose) {
      console.log(`[FastifyExtractor] Parsing: ${fullEntryPath}`);
    }

    // build.tsを解析してルート登録を取得
    const buildParser = new BuildFileParser(fullTsconfigPath);
    const registrations = buildParser.parse(fullEntryPath);

    if (verbose) {
      console.log(`[FastifyExtractor] Found ${registrations.length} route registrations`);
    }

    // 各ルートファイルを解析
    const routeParser = new RouteFileParser(fullTsconfigPath, authConfig);

    const routes = registrations.map(reg => {
      if (verbose) {
        console.log(`[FastifyExtractor] Parsing route: ${reg.resolvedFilePath}`);
      }

      const endpoints = routeParser.parse(reg.resolvedFilePath);

      return {
        prefix: reg.prefix,
        endpoints,
      };
    });

    // 統計を計算
    const allEndpoints = routes.flatMap(r => r.endpoints);
    const authRequiredCount = allEndpoints.filter(e => e.auth.required).length;
    const publicCount = allEndpoints.length - authRequiredCount;

    return {
      framework: 'fastify',
      projectRoot,
      entryFilePath: fullEntryPath,
      routes,
      extractedAt: new Date().toISOString(),
      authRequiredCount,
      publicCount,
    };
  }

  async canHandle(projectRoot: string): Promise<boolean> {
    try {
      const packageJsonPath = `${projectRoot}/package.json`;
      const file = Bun.file(packageJsonPath);
      const content = await file.text();
      const packageJson = JSON.parse(content);

      const allDeps = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies,
      };

      return 'fastify' in allDeps;
    } catch {
      return false;
    }
  }
}
```

---

## AuthDetector {#auth-detector}

### 目的

Fastifyルート定義から認証ミドルウェアを検出する。

### 実装

```typescript
// src/extractors/fastify/authDetector.ts

import { Node, SyntaxKind } from 'ts-morph';
import type { AuthConfig, AuthInfo, FastifyAuthHook } from '../../types';

export class AuthDetector {
  constructor(private config: AuthConfig) {}

  /**
   * ルート定義の引数から認証情報を検出
   */
  detect(args: Node[]): AuthInfo {
    // オプションオブジェクトを探す
    const optionsArg = args.find(arg => Node.isObjectLiteralExpression(arg));

    if (!optionsArg || !Node.isObjectLiteralExpression(optionsArg)) {
      return { required: false, middlewares: [] };
    }

    // 各フックポイントをチェック
    for (const hookPoint of this.config.hookPoints) {
      const hookProp = optionsArg.getProperty(hookPoint);

      if (!hookProp) {
        continue;
      }

      const detectedMiddlewares = this.extractMiddlewareNames(hookProp);
      const authMiddlewares = detectedMiddlewares.filter(name =>
        this.config.middlewareNames.some(
          authName => name.toLowerCase().includes(authName.toLowerCase())
        )
      );

      if (authMiddlewares.length > 0) {
        return {
          required: true,
          middlewares: authMiddlewares,
          hookPoint,
        };
      }
    }

    return { required: false, middlewares: [] };
  }

  /**
   * フックプロパティからミドルウェア名を抽出
   */
  private extractMiddlewareNames(hookProp: Node): readonly string[] {
    const text = hookProp.getText();
    const middlewares: string[] = [];

    // 配列形式: { preHandler: [tokenVerification, anotherMiddleware] }
    // 単一形式: { preHandler: tokenVerification }

    // 識別子を抽出
    hookProp.forEachDescendant(node => {
      if (Node.isIdentifier(node)) {
        const name = node.getText();
        // プロパティ名自体は除外
        if (!this.config.hookPoints.includes(name as FastifyAuthHook)) {
          middlewares.push(name);
        }
      }
    });

    return middlewares;
  }

  /**
   * 部分一致で認証ミドルウェアか判定
   */
  isAuthMiddleware(name: string): boolean {
    return this.config.middlewareNames.some(
      authName => name.toLowerCase().includes(authName.toLowerCase())
    );
  }
}
```

---

## NestJSExtractor（将来実装） {#nestjs-extractor}

### 設計方針

NestJS対応時の実装方針を示す。

```typescript
// src/extractors/nestjs/index.ts（将来）

import type { EndpointExtractor } from '../types';
import type { ExtractorOptions, ExtractedEndpoints, FrameworkType } from '../../types';
import { ControllerParser } from './controllerParser';
import { DecoratorParser } from './decoratorParser';
import { GuardDetector } from './guardDetector';

export class NestJSExtractor implements EndpointExtractor {
  readonly framework: FrameworkType = 'nestjs';

  async extract(options: ExtractorOptions): Promise<ExtractedEndpoints> {
    const { projectRoot, verbose } = options;

    // 1. src/配下の全.tsファイルをスキャン
    // 2. @Controller()デコレータを持つクラスを検出
    // 3. @Get(), @Post()等のデコレータからエンドポイントを抽出
    // 4. @UseGuards()からの認証検出

    const controllerParser = new ControllerParser();
    const decoratorParser = new DecoratorParser();
    const guardDetector = new GuardDetector();

    // コントローラーファイルを検出
    const controllerFiles = await this.findControllerFiles(projectRoot);

    const routes = await Promise.all(
      controllerFiles.map(async filePath => {
        const controller = controllerParser.parse(filePath);
        const endpoints = decoratorParser.parseEndpoints(filePath, controller);

        return {
          prefix: controller.basePath,
          endpoints: endpoints.map(ep => ({
            ...ep,
            auth: guardDetector.detect(ep.decorators),
          })),
        };
      })
    );

    // 統計計算と結果返却
    // ...
  }

  async canHandle(projectRoot: string): Promise<boolean> {
    // @nestjs/coreの存在確認
  }

  private async findControllerFiles(projectRoot: string): Promise<string[]> {
    // *.controller.ts パターンでファイルを検索
  }
}
```

### NestJS解析パターン

```typescript
// 対象パターン

// 1. コントローラー定義
@Controller('users')
export class UsersController {
  // ...
}

// 2. エンドポイント定義
@Get(':id')
async findOne(@Param('id') id: string) { }

@Post()
async create(@Body() dto: CreateUserDto) { }

// 3. 認証（ガード）
@UseGuards(JwtAuthGuard)
@Get('profile')
async getProfile() { }

// 4. Public（認証不要）
@Public()
@Get('health')
async health() { }
```

---

## CLIエントリーポイント更新 {#cli-entry}

### 実装

```typescript
// index.ts

import { ExtractorFactory } from './src/core/extractorFactory';
import { FrameworkDetector } from './src/core/frameworkDetector';
import { YamlGenerator } from './src/generators/yamlGenerator';
import type { CLIOptions, AuthConfig, DEFAULT_AUTH_CONFIG } from './src/types';

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    printUsage();
    process.exit(1);
  }

  const options = parseArgs(args);
  const { projectRoot, framework, verbose, outputPath, authConfig } = options;

  try {
    const factory = new ExtractorFactory();

    // Extractorを取得（フレームワーク指定 or 自動検出）
    const extractor = framework
      ? factory.getExtractor(framework)
      : await factory.getExtractorForProject(projectRoot);

    if (verbose) {
      console.log(`Using ${extractor.framework} extractor`);
    }

    // エンドポイント抽出
    const result = await extractor.extract({
      projectRoot,
      authConfig,
      verbose,
    });

    // YAML出力
    const generator = new YamlGenerator();
    const yaml = generator.generate(result);

    if (outputPath) {
      await Bun.write(outputPath, yaml);
      console.log(`Output written to: ${outputPath}`);
    } else {
      console.log(yaml);
    }

    // サマリー出力
    console.log(`\n--- Summary ---`);
    console.log(`Framework: ${result.framework}`);
    console.log(`Total endpoints: ${result.authRequiredCount + result.publicCount}`);
    console.log(`Auth required: ${result.authRequiredCount}`);
    console.log(`Public: ${result.publicCount}`);

  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

function parseArgs(args: string[]): CLIOptions {
  const projectRoot = args[0];
  const options: Partial<CLIOptions> = { projectRoot };

  for (let i = 1; i < args.length; i++) {
    switch (args[i]) {
      case '--framework':
        options.framework = args[++i] as any;
        break;
      case '--output':
        options.outputPath = args[++i];
        break;
      case '--verbose':
        options.verbose = true;
        break;
      case '--auth-middlewares':
        const middlewares = args[++i].split(',');
        options.authConfig = {
          ...DEFAULT_AUTH_CONFIG,
          middlewareNames: middlewares,
        };
        break;
    }
  }

  return options as CLIOptions;
}

function printUsage() {
  console.log(`
Usage: bun run index.ts <project-path> [options]

Options:
  --framework <name>         Specify framework (fastify, nestjs, express)
  --output <file>            Output file path
  --verbose                  Enable verbose logging
  --auth-middlewares <list>  Comma-separated auth middleware names

Examples:
  bun run index.ts /path/to/project
  bun run index.ts /path/to/project --framework fastify
  bun run index.ts /path/to/project --auth-middlewares tokenVerification,authGuard
  `);
}

main();
```

---

## プラグイン追加手順

新しいフレームワーク（例: Hono）を追加する場合の手順:

### 1. Extractor実装

```typescript
// src/extractors/hono/index.ts

export class HonoExtractor implements EndpointExtractor {
  readonly framework: FrameworkType = 'hono'; // 型に追加が必要

  async extract(options: ExtractorOptions): Promise<ExtractedEndpoints> {
    // Hono固有の解析ロジック
  }

  async canHandle(projectRoot: string): Promise<boolean> {
    // honoパッケージの存在確認
  }
}
```

### 2. Framework型の拡張

```typescript
// src/types/framework.ts

export const FRAMEWORKS = ['fastify', 'nestjs', 'express', 'hono'] as const;
```

### 3. Extractorの登録

```typescript
// src/core/extractorFactory.ts

import { HonoExtractor } from '../extractors/hono';

const EXTRACTORS = new Map([
  ['fastify', FastifyExtractor],
  ['hono', HonoExtractor], // 追加
]);
```

### 4. FrameworkDetectorにパターン追加

```typescript
// src/core/frameworkDetector.ts

const FRAMEWORK_PATTERNS = [
  // ...existing patterns
  {
    framework: 'hono',
    dependencies: ['hono'],
    priority: 4,
  },
];
```

---

## テスト戦略

### 単体テスト

| コンポーネント | テスト内容 |
|--------------|----------|
| FrameworkDetector | 各フレームワークの検出、優先度、複合ケース |
| ExtractorFactory | Extractor生成、未対応フレームワーク |
| FastifyExtractor | canHandle判定、extract結果 |
| AuthDetector | 各フックポイント、複数ミドルウェア |

### 統合テスト

- 実プロジェクトでのend-to-end抽出
- フレームワーク自動検出からYAML出力まで
