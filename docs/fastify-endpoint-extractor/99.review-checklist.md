# レビューチェックリスト: Endpoint Extractor

Updated: 2025/12/29 23:12

## 概要

このファイルはレビューエージェントが参照する品質保証ファイルです。
各設計書の内容に対するレビュー観点を詳細に定義しています。

**目的:**
1. 設計意図の明文化: 実装エージェントが設計の意図を汲み取れなくても、レビューで検出できるようにする
2. コンテキスト完全復旧: 別セッションのレビューエージェントでも、このファイルだけで完全なレビューが可能
3. 省力化・投げ出し検出: 「あるべき姿」を詳細に定義し、不足を見逃さない

---

## レビュー観点一覧

| # | 観点ID | 対象設計書 | チェック内容 | 重要度 |
|---|--------|-----------|-------------|--------|
| 1 | MODEL-001 | 02.models.md | FrameworkType型が正しく定義されていること | HIGH |
| 2 | MODEL-002 | 02.models.md | AuthConfig型がreadonlyで定義されていること | HIGH |
| 3 | MODEL-003 | 02.models.md | AuthInfo型にhookPoint?プロパティがあること | HIGH |
| 4 | MODEL-004 | 02.models.md | EndpointExtractorインターフェースが完全実装されていること | HIGH |
| 5 | MODEL-005 | 02.models.md | DEFAULT_AUTH_CONFIGが8個のミドルウェア名を含むこと | MEDIUM |
| 6 | TEST-001 | 03.tests.md | BuildFileParser正常系テストがあること | HIGH |
| 7 | TEST-002 | 03.tests.md | RouteFileParser型パラメータ抽出テストがあること | HIGH |
| 8 | TEST-003 | 03.tests.md | TypeExtractorオプショナル判定テストがあること | HIGH |
| 9 | TEST-004 | 03.tests.md | AuthDetector複数フックポイントテストがあること | HIGH |
| 10 | PARSER-001 | 04.parser-implementation.md | BuildFileParserがデフォルト・名前付きインポート両方に対応すること | HIGH |
| 11 | PARSER-002 | 04.parser-implementation.md | RouteFileParserが5つ全HTTPメソッドを検出すること | HIGH |
| 12 | PARSER-003 | 04.parser-implementation.md | AuthDetectorが部分一致で検出すること | HIGH |
| 13 | PARSER-004 | 04.parser-implementation.md | AuthDetectorが全フックポイントをループすること | HIGH |
| 14 | PARSER-005 | 04.parser-implementation.md | TypeExtractorがオプショナルを正しく判定すること | HIGH |
| 15 | PARSER-006 | 04.parser-implementation.md | TypeExtractorがリテラル型にクォートを付加すること | MEDIUM |
| 16 | YAML-001 | 05.yaml-output.md | _metaセクションが出力されること | HIGH |
| 17 | YAML-002 | 05.yaml-output.md | 空のパラメータセクションが省略されること | MEDIUM |
| 18 | YAML-003 | 05.yaml-output.md | オプショナルに| undefinedが付加されること | HIGH |
| 19 | ARCH-001 | 06.extractor-architecture.md | FrameworkDetectorがdeps/devDeps両方チェックすること | HIGH |
| 20 | ARCH-002 | 06.extractor-architecture.md | FrameworkDetectorでNestJS優先度が最高であること | HIGH |
| 21 | ARCH-003 | 06.extractor-architecture.md | ExtractorFactoryが未対応フレームワークでエラーを投げること | HIGH |
| 22 | ARCH-004 | 06.extractor-architecture.md | FastifyExtractorがcanHandleでtry-catchを使用すること | HIGH |
| 23 | ARCH-005 | 06.extractor-architecture.md | FastifyExtractorの統計計算が正しいこと | HIGH |
| 24 | CLI-001 | 06.extractor-architecture.md | CLIが引数なしでUsageを表示すること | MEDIUM |
| 25 | CLI-002 | 06.extractor-architecture.md | --auth-middlewaresがカンマ区切りでパースされること | HIGH |

---

## 観点詳細

### MODEL-001: FrameworkType型が正しく定義されていること

**対象設計書**: [02.models.md](./02.models.md#framework-type)
**重要度**: HIGH（必須）
**担当ファイル**: `src/types/framework.ts`

#### 何をチェックするか

FRAMEWORKS定数がas constで定義され、FrameworkType型がその要素型として定義されていること。

#### なぜ必要か

- 型安全なフレームワーク指定のため
- ExtractorFactoryでのマッピングに使用
- 将来のフレームワーク追加時の拡張ポイント

#### 期待される状態

```typescript
// src/types/framework.ts
export const FRAMEWORKS = ['fastify', 'nestjs', 'express'] as const;
export type FrameworkType = (typeof FRAMEWORKS)[number];
```

#### チェック手順

1. `src/types/framework.ts`を読み込む
2. `as const`が使用されていることを確認
3. FrameworkTypeがFRAMEWORKS配列から導出されていることを確認

#### NGパターン

```typescript
// NG: as constがない
export const FRAMEWORKS = ['fastify', 'nestjs', 'express'];

// NG: 型が直接定義されている（配列との同期が取れない）
export type FrameworkType = 'fastify' | 'nestjs' | 'express';
```

---

### MODEL-002: AuthConfig型がreadonlyで定義されていること

**対象設計書**: [02.models.md](./02.models.md#auth-config)
**重要度**: HIGH（必須）
**担当ファイル**: `src/types/auth.ts`

#### 何をチェックするか

AuthConfig型の全プロパティがreadonlyで定義されていること。

#### なぜ必要か

- イミュータビリティの確保
- コード品質ルール（no-object-mutation）への準拠
- 設定の不変性保証

#### 期待される状態

```typescript
export type AuthConfig = {
  readonly middlewareNames: readonly string[];
  readonly hookPoints: readonly FastifyAuthHook[];
};
```

#### チェック手順

1. `src/types/auth.ts`を読み込む
2. AuthConfig型定義を確認
3. 全プロパティにreadonlyが付いていることを確認
4. 配列型にもreadonlyが付いていることを確認

#### NGパターン

```typescript
// NG: readonlyがない
export type AuthConfig = {
  middlewareNames: string[];
  hookPoints: FastifyAuthHook[];
};

// NG: 配列のreadonlyがない
export type AuthConfig = {
  readonly middlewareNames: string[];  // 配列自体はmutable
  readonly hookPoints: FastifyAuthHook[];
};
```

---

### MODEL-003: AuthInfo型にhookPoint?プロパティがあること

**対象設計書**: [02.models.md](./02.models.md#endpoint-info)
**重要度**: HIGH（必須）
**担当ファイル**: `src/types/endpoint.ts`

#### 何をチェックするか

AuthInfo型にオプショナルなhookPointプロパティが定義されていること。

#### なぜ必要か

- どのフックで認証が検出されたかを記録するため
- デバッグ・ログ出力で有用
- 認証なしの場合はundefinedになるため

#### 期待される状態

```typescript
export type AuthInfo = {
  readonly required: boolean;
  readonly middlewares: readonly string[];
  readonly hookPoint?: string;  // オプショナル
};
```

#### チェック手順

1. `src/types/endpoint.ts`を読み込む
2. AuthInfo型定義を確認
3. hookPointプロパティが`?`付きで定義されていることを確認

#### NGパターン

```typescript
// NG: hookPointがない
export type AuthInfo = {
  readonly required: boolean;
  readonly middlewares: readonly string[];
};

// NG: hookPointが必須
export type AuthInfo = {
  readonly required: boolean;
  readonly middlewares: readonly string[];
  readonly hookPoint: string;  // 認証なしの場合に問題
};
```

---

### MODEL-004: EndpointExtractorインターフェースが完全実装されていること

**対象設計書**: [02.models.md](./02.models.md#endpoint-extractor)
**重要度**: HIGH（必須）
**担当ファイル**: `src/extractors/types.ts`

#### 何をチェックするか

EndpointExtractorインターフェースに3つのメンバー（framework, extract, canHandle）が定義されていること。

#### なぜ必要か

- 全Extractor実装の契約として機能
- ExtractorFactoryでの一貫した扱いを保証
- 新フレームワーク追加時のガイドライン

#### 期待される状態

```typescript
export interface EndpointExtractor {
  readonly framework: FrameworkType;
  extract(options: ExtractorOptions): Promise<ExtractedEndpoints>;
  canHandle(projectRoot: string): Promise<boolean>;
}
```

#### チェック手順

1. `src/extractors/types.ts`を読み込む
2. EndpointExtractorインターフェースを確認
3. frameworkがreadonly FrameworkType型であることを確認
4. extractメソッドのシグネチャを確認
5. canHandleメソッドのシグネチャを確認

#### NGパターン

```typescript
// NG: frameworkがreadonlyでない
export interface EndpointExtractor {
  framework: FrameworkType;  // readonlyなし
  // ...
}

// NG: canHandleがない
export interface EndpointExtractor {
  readonly framework: FrameworkType;
  extract(options: ExtractorOptions): Promise<ExtractedEndpoints>;
  // canHandleが欠落
}

// NG: 戻り値がPromiseでない
export interface EndpointExtractor {
  extract(options: ExtractorOptions): ExtractedEndpoints;  // 同期
}
```

---

### MODEL-005: DEFAULT_AUTH_CONFIGが8個のミドルウェア名を含むこと

**対象設計書**: [02.models.md](./02.models.md#auth-config)
**重要度**: MEDIUM
**担当ファイル**: `src/types/auth.ts`

#### 何をチェックするか

DEFAULT_AUTH_MIDDLEWARESに8個のデフォルト認証ミドルウェア名が含まれていること。

#### なぜ必要か

- 一般的な認証関数名をカバーするため
- 設定なしでも基本的な認証検出が機能するため

#### 期待される状態

```typescript
export const DEFAULT_AUTH_MIDDLEWARES = [
  'tokenVerification',
  'authGuard',
  'authenticate',
  'requireAuth',
  'verifyToken',
  'isAuthenticated',
  'authMiddleware',
  'jwtVerify',
] as const;
```

#### チェック手順

1. `src/types/auth.ts`を読み込む
2. DEFAULT_AUTH_MIDDLEWARESを確認
3. 8個の要素があることを確認
4. 設計書に記載の全ミドルウェア名が含まれていることを確認

#### NGパターン

```typescript
// NG: 要素数が不足
export const DEFAULT_AUTH_MIDDLEWARES = [
  'tokenVerification',
  'authenticate',
] as const;  // 2個しかない
```

---

### PARSER-001: BuildFileParserがデフォルト・名前付きインポート両方に対応すること

**対象設計書**: [04.parser-implementation.md](./04.parser-implementation.md#build-file-parser)
**重要度**: HIGH（必須）
**担当ファイル**: `src/extractors/fastify/buildFileParser.ts`

#### 何をチェックするか

buildImportMapメソッドがデフォルトインポートと名前付きインポートの両方を処理していること。

#### なぜ必要か

- `import Users from './routes'`（デフォルト）と`import { Users } from './routes'`（名前付き）両方に対応するため
- エイリアス（`import { Users as UserRoutes }`）にも対応するため

#### 期待される状態

```typescript
private buildImportMap(sourceFile: SourceFile): Map<string, string> {
  const map = new Map<string, string>();

  sourceFile.getImportDeclarations().forEach(imp => {
    const moduleSpecifier = imp.getModuleSpecifierValue();

    // デフォルトインポート
    const defaultImport = imp.getDefaultImport();
    if (defaultImport) {
      map.set(defaultImport.getText(), moduleSpecifier);
    }

    // 名前付きインポート（エイリアス対応）
    imp.getNamedImports().forEach(named => {
      const name = named.getAliasNode()?.getText() ?? named.getName();
      map.set(name, moduleSpecifier);
    });
  });

  return map;
}
```

#### チェック手順

1. `src/extractors/fastify/buildFileParser.ts`を読み込む
2. buildImportMapメソッドを確認
3. getDefaultImport()の処理があることを確認
4. getNamedImports()の処理があることを確認
5. getAliasNode()でエイリアス対応していることを確認

#### NGパターン

```typescript
// NG: デフォルトインポートのみ
private buildImportMap(sourceFile: SourceFile): Map<string, string> {
  const map = new Map<string, string>();
  sourceFile.getImportDeclarations().forEach(imp => {
    const defaultImport = imp.getDefaultImport();
    if (defaultImport) {
      map.set(defaultImport.getText(), imp.getModuleSpecifierValue());
    }
    // 名前付きインポートの処理がない
  });
  return map;
}

// NG: エイリアス未対応
imp.getNamedImports().forEach(named => {
  map.set(named.getName(), moduleSpecifier);  // getAliasNode()がない
});
```

#### 関連観点

- TEST-001: BuildFileParser正常系テストがあること

---

### PARSER-002: RouteFileParserが5つ全HTTPメソッドを検出すること

**対象設計書**: [04.parser-implementation.md](./04.parser-implementation.md#route-file-parser)
**重要度**: HIGH（必須）
**担当ファイル**: `src/extractors/fastify/routeFileParser.ts`

#### 何をチェックするか

GET, POST, PUT, DELETE, PATCHの5つ全てのHTTPメソッドが検出対象であること。

#### なぜ必要か

- 全RESTエンドポイントをカバーするため
- HTTPメソッドの見落としを防ぐため

#### 期待される状態

```typescript
import { HTTP_METHODS } from '../../types';  // ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']

private findHttpMethodCalls(sourceFile: SourceFile): readonly CallExpression[] {
  const methodNames = HTTP_METHODS.map(m => m.toLowerCase());

  return sourceFile
    .getDescendantsOfKind(SyntaxKind.CallExpression)
    .filter(call => {
      const expr = call.getExpression();
      if (!Node.isPropertyAccessExpression(expr)) {
        return false;
      }
      const methodName = expr.getName().toLowerCase();
      return methodNames.includes(methodName);
    });
}
```

#### チェック手順

1. `src/extractors/fastify/routeFileParser.ts`を読み込む
2. HTTP_METHODSがインポートされているか、または5メソッド全てがハードコードされているか確認
3. toLowerCase()で大文字小文字を無視していることを確認

#### NGパターン

```typescript
// NG: 一部のメソッドのみ
const methodNames = ['get', 'post'];  // PUT, DELETE, PATCHがない

// NG: 大文字小文字を考慮していない
const methodName = expr.getName();  // toLowerCase()がない
return ['get', 'post', 'put', 'delete', 'patch'].includes(methodName);
```

---

### PARSER-003: AuthDetectorが部分一致で検出すること

**対象設計書**: [04.parser-implementation.md](./04.parser-implementation.md#auth-detector)
**重要度**: HIGH（必須）
**担当ファイル**: `src/extractors/fastify/authDetector.ts`

#### 何をチェックするか

isAuthMiddlewareメソッドが部分一致（includes）で認証ミドルウェアを検出していること。

#### なぜ必要か

- `customTokenVerification`のような名前でも`tokenVerification`パターンで検出するため
- 大文字小文字を無視して柔軟にマッチするため

#### 期待される状態

```typescript
isAuthMiddleware(name: string): boolean {
  const lowerName = name.toLowerCase();
  return this.config.middlewareNames.some(
    authName => lowerName.includes(authName.toLowerCase())
  );
}
```

#### チェック手順

1. `src/extractors/fastify/authDetector.ts`を読み込む
2. isAuthMiddlewareメソッドを確認
3. includes()が使用されていることを確認
4. toLowerCase()で大文字小文字を無視していることを確認

#### NGパターン

```typescript
// NG: 完全一致のみ
isAuthMiddleware(name: string): boolean {
  return this.config.middlewareNames.includes(name);
}

// NG: 大文字小文字を考慮していない
isAuthMiddleware(name: string): boolean {
  return this.config.middlewareNames.some(
    authName => name.includes(authName)  // toLowerCaseがない
  );
}
```

---

### PARSER-004: AuthDetectorが全フックポイントをループすること

**対象設計書**: [04.parser-implementation.md](./04.parser-implementation.md#auth-detector)
**重要度**: HIGH（必須）
**担当ファイル**: `src/extractors/fastify/authDetector.ts`

#### 何をチェックするか

detectメソッドがconfig.hookPointsの全要素をループしてチェックしていること。

#### なぜ必要か

- preHandler, onRequest, preValidationなど複数フックに対応するため
- 設定で指定された全てのフックポイントをカバーするため

#### 期待される状態

```typescript
detect(args: Node[]): AuthInfo {
  // ...
  for (const hookPoint of this.config.hookPoints) {
    const hookProp = optionsArg.getProperty(hookPoint);
    if (!hookProp) {
      continue;
    }
    // 認証検出ロジック
  }
  // ...
}
```

#### チェック手順

1. `src/extractors/fastify/authDetector.ts`を読み込む
2. detectメソッドを確認
3. this.config.hookPointsをループしていることを確認
4. 最初に見つかった認証で即returnしていることを確認

#### NGパターン

```typescript
// NG: preHandlerのみ固定
detect(args: Node[]): AuthInfo {
  const hookProp = optionsArg.getProperty('preHandler');  // 他のフックを見ていない
  // ...
}

// NG: ハードコードされたフックリスト
for (const hookPoint of ['preHandler', 'onRequest']) {  // configを使っていない
  // ...
}
```

---

### PARSER-005: TypeExtractorがオプショナルを正しく判定すること

**対象設計書**: [04.parser-implementation.md](./04.parser-implementation.md#type-extractor)
**重要度**: HIGH（必須）
**担当ファイル**: `src/core/typeExtractor.ts`

#### 何をチェックするか

symbol.isOptional()を使用してオプショナルプロパティを判定していること。

#### なぜ必要か

- `email?: string`と`email: string`を区別するため
- YAML出力で`| undefined`の付加を決定するため

#### 期待される状態

```typescript
private extractPropertyInfo(symbol: TsSymbol, parentType: Type): ParamInfo {
  const name = symbol.getName();
  // ...
  const isOptional = symbol.isOptional();

  return {
    name,
    type: typeText,
    required: !isOptional,
  };
}
```

#### チェック手順

1. `src/core/typeExtractor.ts`を読み込む
2. extractPropertyInfoメソッドを確認
3. symbol.isOptional()が呼び出されていることを確認
4. requiredが`!isOptional`で設定されていることを確認

#### NGパターン

```typescript
// NG: オプショナル判定がない
return {
  name,
  type: typeText,
  required: true,  // 常にtrue
};

// NG: 型名から判定しようとしている
const isOptional = typeText.includes('undefined');  // 不正確
```

---

### PARSER-006: TypeExtractorがリテラル型にクォートを付加すること

**対象設計書**: [04.parser-implementation.md](./04.parser-implementation.md#type-extractor)
**重要度**: MEDIUM
**担当ファイル**: `src/core/typeExtractor.ts`

#### 何をチェックするか

文字列リテラル型（`'active'`など）を出力する際にクォートが付加されていること。

#### なぜ必要か

- `'active' | 'inactive'`のような型を正しく表現するため
- 文字列リテラルと通常の文字列型（string）を区別するため

#### 期待される状態

```typescript
private formatType(type: Type): string {
  // ...
  if (type.isStringLiteral()) {
    return `'${type.getLiteralValue()}'`;  // クォート付加
  }
  // ...
}
```

#### チェック手順

1. `src/core/typeExtractor.ts`を読み込む
2. formatTypeメソッドを確認
3. isStringLiteral()の分岐があることを確認
4. getLiteralValue()の結果にクォートが付加されていることを確認

#### NGパターン

```typescript
// NG: クォートがない
if (type.isStringLiteral()) {
  return String(type.getLiteralValue());  // 'active' ではなく active になる
}
```

---

### YAML-001: _metaセクションが出力されること

**対象設計書**: [05.yaml-output.md](./05.yaml-output.md)
**重要度**: HIGH（必須）
**担当ファイル**: `src/generators/yamlGenerator.ts`

#### 何をチェックするか

YAML出力に_metaセクションが含まれ、必要なフィールドが全て出力されること。

#### なぜ必要か

- 出力の追跡可能性（いつ、どこから生成されたか）
- 統計情報の提供
- YAML消費者へのコンテキスト提供

#### 期待される状態

```typescript
private buildYamlOutput(data: ExtractedEndpoints): Record<string, unknown> {
  const output: Record<string, unknown> = {
    _meta: {
      framework: data.framework,
      projectRoot: data.projectRoot,
      extractedAt: data.extractedAt,
      totalEndpoints: data.routes.reduce((sum, r) => sum + r.endpoints.length, 0),
      authRequiredCount: data.authRequiredCount,
      publicCount: data.publicCount,
    },
  };
  // ...
}
```

#### チェック手順

1. `src/generators/yamlGenerator.ts`を読み込む
2. buildYamlOutputメソッドを確認
3. _metaキーが設定されていることを確認
4. framework, projectRoot, extractedAt, totalEndpoints, authRequiredCount, publicCountが含まれていることを確認

#### NGパターン

```typescript
// NG: _metaがない
private buildYamlOutput(data: ExtractedEndpoints): Record<string, unknown> {
  const output: Record<string, unknown> = {};
  // _metaがない
  data.routes.forEach(route => {
    output[route.prefix] = this.buildYamlRoute(route.endpoints);
  });
  return output;
}
```

---

### YAML-002: 空のパラメータセクションが省略されること

**対象設計書**: [05.yaml-output.md](./05.yaml-output.md)
**重要度**: MEDIUM
**担当ファイル**: `src/generators/yamlGenerator.ts`

#### 何をチェックするか

pathParams, queryParams, bodyParamsが空配列の場合、YAMLに出力されないこと。

#### なぜ必要か

- 冗長な出力を避けるため
- YAMLファイルサイズの最適化
- 可読性の向上

#### 期待される状態

```typescript
private buildYamlEndpoint(endpoint: EndpointInfo): YamlEndpoint {
  const result: Record<string, unknown> = {
    METHOD: endpoint.method,
  };

  if (endpoint.pathParams.length > 0) {
    result.pathParams = this.buildYamlParams(endpoint.pathParams);
  }
  if (endpoint.queryParams.length > 0) {
    result.queryParams = this.buildYamlParams(endpoint.queryParams);
  }
  if (endpoint.bodyParams.length > 0) {
    result.bodyParams = this.buildYamlParams(endpoint.bodyParams);
  }
  // ...
}
```

#### チェック手順

1. `src/generators/yamlGenerator.ts`を読み込む
2. buildYamlEndpointメソッドを確認
3. 各パラメータ配列に対して`.length > 0`のチェックがあることを確認

#### NGパターン

```typescript
// NG: 常にパラメータセクションを出力
result.pathParams = this.buildYamlParams(endpoint.pathParams);
result.queryParams = this.buildYamlParams(endpoint.queryParams);
result.bodyParams = this.buildYamlParams(endpoint.bodyParams);
// 空でも pathParams: {} が出力される
```

---

### YAML-003: オプショナルに| undefinedが付加されること

**対象設計書**: [05.yaml-output.md](./05.yaml-output.md)
**重要度**: HIGH（必須）
**担当ファイル**: `src/generators/yamlGenerator.ts`

#### 何をチェックするか

required: falseのパラメータの型に` | undefined`が付加されていること。

#### なぜ必要か

- オプショナルパラメータを明示するため
- YAMLを読む人が必須/任意を判断できるようにするため

#### 期待される状態

```typescript
private buildYamlParams(params: readonly ParamInfo[]): YamlParams {
  const result: Record<string, string> = {};

  params.forEach(param => {
    const typeStr = param.required
      ? param.type
      : `${param.type} | undefined`;
    result[param.name] = typeStr;
  });

  return result;
}
```

#### チェック手順

1. `src/generators/yamlGenerator.ts`を読み込む
2. buildYamlParamsメソッドを確認
3. param.requiredでの分岐があることを確認
4. falseの場合に` | undefined`が付加されていることを確認

#### NGパターン

```typescript
// NG: requiredを無視
params.forEach(param => {
  result[param.name] = param.type;  // 常にそのまま
});
```

---

### ARCH-001: FrameworkDetectorがdeps/devDeps両方チェックすること

**対象設計書**: [06.extractor-architecture.md](./06.extractor-architecture.md#framework-detector)
**重要度**: HIGH（必須）
**担当ファイル**: `src/core/frameworkDetector.ts`

#### 何をチェックするか

detectメソッドがdependenciesとdevDependenciesの両方を統合してチェックしていること。

#### なぜ必要か

- 開発時依存としてフレームワークが記載されるケースがあるため
- モノレポ等で依存関係の記載場所が異なる場合に対応するため

#### 期待される状態

```typescript
async detect(projectRoot: string): Promise<FrameworkDetectionResult | null> {
  // ...
  const allDeps = {
    ...packageJson.dependencies,
    ...packageJson.devDependencies,
  };
  // allDepsを使ってチェック
}
```

#### チェック手順

1. `src/core/frameworkDetector.ts`を読み込む
2. detectメソッドを確認
3. dependenciesとdevDependenciesをマージしていることを確認

#### NGパターン

```typescript
// NG: dependenciesのみ
const deps = packageJson.dependencies;
```

---

### ARCH-002: FrameworkDetectorでNestJS優先度が最高であること

**対象設計書**: [06.extractor-architecture.md](./06.extractor-architecture.md#framework-detector)
**重要度**: HIGH（必須）
**担当ファイル**: `src/core/frameworkDetector.ts`

#### 何をチェックするか

FRAMEWORK_PATTERNSでNestJSのpriorityが最も低い値（高い優先度）であること。

#### なぜ必要か

- NestJSはFastify/Expressと併用されることがあるため
- NestJSが検出された場合はNestJS Extractorを使うべきため

#### 期待される状態

```typescript
const FRAMEWORK_PATTERNS = [
  {
    framework: 'nestjs',
    dependencies: ['@nestjs/core', '@nestjs/common'],
    priority: 1,  // 最優先
  },
  {
    framework: 'fastify',
    dependencies: ['fastify'],
    priority: 2,
  },
  {
    framework: 'express',
    dependencies: ['express'],
    priority: 3,
  },
];
```

#### チェック手順

1. `src/core/frameworkDetector.ts`を読み込む
2. FRAMEWORK_PATTERNSを確認
3. nestjsのpriorityが最小値であることを確認
4. ソート後にnestjsが最初にチェックされることを確認

#### NGパターン

```typescript
// NG: 優先度が同じ
{ framework: 'nestjs', priority: 1 },
{ framework: 'fastify', priority: 1 },

// NG: fastifyが優先
{ framework: 'fastify', priority: 1 },
{ framework: 'nestjs', priority: 2 },
```

---

### ARCH-003: ExtractorFactoryが未対応フレームワークでエラーを投げること

**対象設計書**: [06.extractor-architecture.md](./06.extractor-architecture.md#extractor-factory)
**重要度**: HIGH（必須）
**担当ファイル**: `src/core/extractorFactory.ts`

#### 何をチェックするか

getExtractorメソッドが未登録のフレームワークに対してエラーを投げること。

#### なぜ必要か

- 明確なエラーメッセージでユーザーに問題を伝えるため
- サイレントに失敗しないため

#### 期待される状態

```typescript
getExtractor(framework: FrameworkType): EndpointExtractor {
  const ExtractorClass = EXTRACTORS.get(framework);

  if (!ExtractorClass) {
    throw new Error(`Unsupported framework: ${framework}`);
  }

  return new ExtractorClass();
}
```

#### チェック手順

1. `src/core/extractorFactory.ts`を読み込む
2. getExtractorメソッドを確認
3. EXTRACTORSからの取得後にnullチェックがあることを確認
4. エラーメッセージにフレームワーク名が含まれることを確認

#### NGパターン

```typescript
// NG: エラーを投げない
getExtractor(framework: FrameworkType): EndpointExtractor | null {
  const ExtractorClass = EXTRACTORS.get(framework);
  return ExtractorClass ? new ExtractorClass() : null;
}

// NG: エラーメッセージが不明確
throw new Error('Invalid framework');  // どのフレームワークかわからない
```

---

### ARCH-004: FastifyExtractorがcanHandleでtry-catchを使用すること

**対象設計書**: [06.extractor-architecture.md](./06.extractor-architecture.md#fastify-extractor)
**重要度**: HIGH（必須）
**担当ファイル**: `src/extractors/fastify/index.ts`

#### 何をチェックするか

canHandleメソッドがファイル読み込みエラーをキャッチしてfalseを返すこと。

#### なぜ必要か

- package.jsonが存在しない場合でもクラッシュしないため
- 複数Extractorを試行する際にエラーで中断しないため

#### 期待される状態

```typescript
async canHandle(projectRoot: string): Promise<boolean> {
  try {
    const file = Bun.file(`${projectRoot}/package.json`);
    const content = await file.text();
    const packageJson = JSON.parse(content);
    // ...
    return 'fastify' in allDeps;
  } catch {
    return false;
  }
}
```

#### チェック手順

1. `src/extractors/fastify/index.ts`を読み込む
2. canHandleメソッドを確認
3. try-catchで囲まれていることを確認
4. catchブロックでfalseを返していることを確認

#### NGパターン

```typescript
// NG: try-catchがない
async canHandle(projectRoot: string): Promise<boolean> {
  const file = Bun.file(`${projectRoot}/package.json`);
  const content = await file.text();  // ファイルがないと例外
  // ...
}
```

---

### ARCH-005: FastifyExtractorの統計計算が正しいこと

**対象設計書**: [06.extractor-architecture.md](./06.extractor-architecture.md#fastify-extractor)
**重要度**: HIGH（必須）
**担当ファイル**: `src/extractors/fastify/index.ts`

#### 何をチェックするか

authRequiredCountとpublicCountの計算が全エンドポイントをフラット化して正しくカウントしていること。

#### なぜ必要か

- メタ情報の正確性を保証するため
- 誤った統計情報はユーザーを混乱させるため

#### 期待される状態

```typescript
const allEndpoints = routes.flatMap(r => r.endpoints);
const authRequiredCount = allEndpoints.filter(e => e.auth.required).length;
const publicCount = allEndpoints.length - authRequiredCount;
```

#### チェック手順

1. `src/extractors/fastify/index.ts`を読み込む
2. extractメソッドの統計計算部分を確認
3. flatMapで全エンドポイントをフラット化していることを確認
4. authRequiredCountがauth.requiredでフィルタされていることを確認
5. publicCountが差分で計算されていることを確認

#### NGパターン

```typescript
// NG: ルート数をカウントしている
const authRequiredCount = routes.filter(r =>
  r.endpoints.some(e => e.auth.required)
).length;  // ルート数であってエンドポイント数ではない

// NG: 個別にカウントして不整合
const authRequiredCount = allEndpoints.filter(e => e.auth.required).length;
const publicCount = allEndpoints.filter(e => !e.auth.required).length;
// 合計が総数と一致しない可能性
```

---

### CLI-001: CLIが引数なしでUsageを表示すること

**対象設計書**: [06.extractor-architecture.md](./06.extractor-architecture.md#cli-entry)
**重要度**: MEDIUM
**担当ファイル**: `index.ts`

#### 何をチェックするか

引数が0個の場合にprintUsageを呼び出してexit(1)すること。

#### なぜ必要か

- ユーザーが使い方を理解できるようにするため
- エラー終了コードを返すため

#### 期待される状態

```typescript
async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    printUsage();
    process.exit(1);
  }
  // ...
}
```

#### チェック手順

1. `index.ts`を読み込む
2. mainの先頭でargs.length === 0のチェックがあることを確認
3. printUsage()が呼ばれていることを確認
4. process.exit(1)で終了していることを確認

#### NGパターン

```typescript
// NG: チェックがない
async function main() {
  const args = process.argv.slice(2);
  const projectRoot = args[0];  // undefinedになる可能性
  // ...
}
```

---

### CLI-002: --auth-middlewaresがカンマ区切りでパースされること

**対象設計書**: [06.extractor-architecture.md](./06.extractor-architecture.md#cli-entry)
**重要度**: HIGH（必須）
**担当ファイル**: `index.ts`

#### 何をチェックするか

--auth-middlewaresオプションの値がカンマで分割されて配列になること。

#### なぜ必要か

- 複数のミドルウェア名を指定できるようにするため
- CLIの使いやすさを確保するため

#### 期待される状態

```typescript
case '--auth-middlewares':
  const middlewares = args[++i].split(',');
  options.authConfig = {
    ...DEFAULT_AUTH_CONFIG,
    middlewareNames: middlewares,
  };
  break;
```

#### チェック手順

1. `index.ts`を読み込む
2. parseArgs関数を確認
3. --auth-middlewaresのcase文を確認
4. split(',')が呼ばれていることを確認
5. DEFAULT_AUTH_CONFIGをスプレッドしていることを確認

#### NGパターン

```typescript
// NG: 分割していない
case '--auth-middlewares':
  options.authConfig = { middlewareNames: args[++i] };  // 文字列のまま

// NG: デフォルト設定を無視
case '--auth-middlewares':
  const middlewares = args[++i].split(',');
  options.authConfig = { middlewareNames: middlewares };  // hookPointsがない
```

---

## 設計書別チェックサマリー

### 02.models.md 関連

| 観点ID | 内容 | 完了条件 |
|--------|------|---------|
| MODEL-001 | FrameworkType型定義 | as constとtypeof使用 |
| MODEL-002 | AuthConfig readonly | 全プロパティにreadonly |
| MODEL-003 | AuthInfo.hookPoint? | オプショナルプロパティ |
| MODEL-004 | EndpointExtractorインターフェース | 3メンバー完備 |
| MODEL-005 | DEFAULT_AUTH_MIDDLEWARES | 8個のミドルウェア名 |

### 03.tests.md 関連

| 観点ID | 内容 | 完了条件 |
|--------|------|---------|
| TEST-001 | BuildFileParser正常系 | register抽出テスト存在 |
| TEST-002 | RouteFileParser型パラメータ | ジェネリック型抽出テスト存在 |
| TEST-003 | TypeExtractorオプショナル | ?プロパティ判定テスト存在 |
| TEST-004 | AuthDetector複数フック | preHandler/onRequest両テスト |

### 04.parser-implementation.md 関連

| 観点ID | 内容 | 完了条件 |
|--------|------|---------|
| PARSER-001 | BuildFileParserインポート対応 | default/named両対応 |
| PARSER-002 | RouteFileParser HTTPメソッド | 5メソッド全検出 |
| PARSER-003 | AuthDetector部分一致 | includes使用 |
| PARSER-004 | AuthDetectorフックループ | config.hookPoints全チェック |
| PARSER-005 | TypeExtractorオプショナル | isOptional()使用 |
| PARSER-006 | TypeExtractorリテラル | クォート付加 |

### 05.yaml-output.md 関連

| 観点ID | 内容 | 完了条件 |
|--------|------|---------|
| YAML-001 | _metaセクション | 6フィールド出力 |
| YAML-002 | 空パラメータ省略 | length > 0チェック |
| YAML-003 | オプショナル表現 | `\| undefined`付加 |

### 06.extractor-architecture.md 関連

| 観点ID | 内容 | 完了条件 |
|--------|------|---------|
| ARCH-001 | FrameworkDetector依存チェック | deps/devDeps両方 |
| ARCH-002 | NestJS優先度 | priority最小 |
| ARCH-003 | ExtractorFactoryエラー | 未対応でthrow |
| ARCH-004 | canHandle try-catch | エラー時false |
| ARCH-005 | 統計計算 | flatMap使用 |
| CLI-001 | 引数なしUsage | printUsage+exit(1) |
| CLI-002 | auth-middlewaresパース | split(',') |

---

## レビュー実行手順

1. このファイルを読み込む
2. 「レビュー観点一覧」の各観点について順番にチェック
3. 「観点詳細」セクションで詳細なチェック手順を確認
4. 各観点について PASS/FAIL を判定
5. FAILの場合は「NGパターン」と照合して問題を特定
6. レビュー結果を出力

---

## レビュー結果フォーマット

```markdown
# レビュー結果: Endpoint Extractor

実施日時: YYYY/MM/DD HH:mm

## サマリー

- PASS: X件
- FAIL: Y件
- SKIP: Z件

## 詳細

### PASS

| 観点ID | 内容 | 確認ファイル |
|--------|------|-------------|
| MODEL-001 | FrameworkType型定義 | src/types/framework.ts:3 |

### FAIL

| 観点ID | 内容 | 問題 | 修正指示 |
|--------|------|------|---------|
| PARSER-003 | AuthDetector部分一致 | includes未使用 | isAuthMiddlewareでincludesを使用 |

### 修正依頼

以下の修正を実施してください:

1. PARSER-003: `src/extractors/fastify/authDetector.ts` のisAuthMiddlewareメソッド修正
   - 参照: 04.parser-implementation.md#auth-detector
```
