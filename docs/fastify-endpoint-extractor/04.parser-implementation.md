# パーサー実装設計

Updated: 2025/12/29 21:50

## 概要

TypeScript AST（ts-morph）を使用したFastifyエンドポイント解析の実装設計。

---

## ts-morph 基本概念

### Project

TypeScriptプロジェクト全体を表す。tsconfigを読み込んで型解決を行う。

```typescript
import { Project } from 'ts-morph';

const project = new Project({
  tsConfigFilePath: '/path/to/tsconfig.json',
});

// ファイルを追加
const sourceFile = project.addSourceFileAtPath('/path/to/file.ts');
```

### SourceFile

単一のTypeScriptファイルを表す。

```typescript
// import文を取得
const imports = sourceFile.getImportDeclarations();

// 関数を取得
const functions = sourceFile.getFunctions();

// 特定のパターンを検索
const callExpressions = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);
```

### AST走査パターン

```typescript
// 特定の種類のノードを全て取得
sourceFile.forEachDescendant((node) => {
  if (Node.isCallExpression(node)) {
    // CallExpressionの処理
  }
});

// 条件に合うノードを検索
const nodes = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression)
  .filter(node => {
    const expr = node.getExpression();
    return Node.isPropertyAccessExpression(expr) &&
           expr.getName() === 'register';
  });
```

---

## BuildFileParser {#build-file-parser}

### 目的

`build.ts`を解析して`app.register(Routes, { prefix })`の呼び出しを検出し、
ルートモジュールとprefixのマッピングを抽出する。

### 解析対象パターン

```typescript
// パターン1: 直接インポート
import Users from './routes/users';
app.register(Users, { prefix: '/users' });

// パターン2: 名前付きインポート
import { UsersRoutes } from './routes/users';
app.register(UsersRoutes, { prefix: '/users' });

// パターン3: 条件分岐内
if (condition) {
  app.register(Social, { prefix: '/social' });
}
```

### 実装

```typescript
// src/parsers/buildFileParser.ts

import {
  Project,
  SourceFile,
  Node,
  SyntaxKind,
  CallExpression,
  ImportDeclaration,
} from 'ts-morph';
import type { RouteRegistration } from '../types';
import * as path from 'path';

export class BuildFileParser {
  private project: Project;

  constructor(tsconfigPath?: string) {
    this.project = new Project({
      tsConfigFilePath: tsconfigPath,
      skipAddingFilesFromTsConfig: true,
    });
  }

  /**
   * build.tsファイルを解析してルート登録情報を抽出
   */
  parse(buildFilePath: string): readonly RouteRegistration[] {
    const sourceFile = this.project.addSourceFileAtPath(buildFilePath);
    return this.parseSourceFile(sourceFile, buildFilePath);
  }

  /**
   * ソース文字列から解析（テスト用）
   */
  parseFromSource(source: string, filePath: string): readonly RouteRegistration[] {
    const sourceFile = this.project.createSourceFile(filePath, source, {
      overwrite: true,
    });
    return this.parseSourceFile(sourceFile, filePath);
  }

  private parseSourceFile(
    sourceFile: SourceFile,
    buildFilePath: string
  ): readonly RouteRegistration[] {
    // import文からモジュール名とパスのマッピングを構築
    const importMap = this.buildImportMap(sourceFile);

    // app.register呼び出しを検出
    const registerCalls = this.findRegisterCalls(sourceFile);

    // ルート登録情報を構築
    return registerCalls
      .map(call => this.extractRegistration(call, importMap, buildFilePath))
      .filter((r): r is RouteRegistration => r !== null);
  }

  /**
   * import文からモジュール名 -> パスのマップを構築
   */
  private buildImportMap(sourceFile: SourceFile): Map<string, string> {
    const map = new Map<string, string>();

    sourceFile.getImportDeclarations().forEach(imp => {
      const moduleSpecifier = imp.getModuleSpecifierValue();

      // デフォルトインポート
      const defaultImport = imp.getDefaultImport();
      if (defaultImport) {
        map.set(defaultImport.getText(), moduleSpecifier);
      }

      // 名前付きインポート
      imp.getNamedImports().forEach(named => {
        const name = named.getAliasNode()?.getText() ?? named.getName();
        map.set(name, moduleSpecifier);
      });
    });

    return map;
  }

  /**
   * app.register / server.register 呼び出しを検出
   */
  private findRegisterCalls(sourceFile: SourceFile): readonly CallExpression[] {
    return sourceFile
      .getDescendantsOfKind(SyntaxKind.CallExpression)
      .filter(call => {
        const expr = call.getExpression();
        if (!Node.isPropertyAccessExpression(expr)) {
          return false;
        }
        return expr.getName() === 'register';
      });
  }

  /**
   * register呼び出しからルート登録情報を抽出
   */
  private extractRegistration(
    call: CallExpression,
    importMap: Map<string, string>,
    buildFilePath: string
  ): RouteRegistration | null {
    const args = call.getArguments();
    if (args.length < 2) {
      return null;
    }

    // 第1引数: ルートモジュール
    const moduleArg = args[0];
    const importName = moduleArg.getText();
    const importPath = importMap.get(importName);

    if (!importPath) {
      return null;
    }

    // 第2引数: オプション { prefix: '...' }
    const optionsArg = args[1];
    const prefix = this.extractPrefix(optionsArg);

    if (!prefix) {
      return null;
    }

    // ファイルパスを解決
    const buildDir = path.dirname(buildFilePath);
    const resolvedFilePath = this.resolveFilePath(buildDir, importPath);

    return {
      importName,
      importPath,
      prefix,
      resolvedFilePath,
    };
  }

  /**
   * オプションオブジェクトからprefixを抽出
   */
  private extractPrefix(optionsNode: Node): string | null {
    if (!Node.isObjectLiteralExpression(optionsNode)) {
      return null;
    }

    const prefixProp = optionsNode.getProperty('prefix');
    if (!prefixProp || !Node.isPropertyAssignment(prefixProp)) {
      return null;
    }

    const initializer = prefixProp.getInitializer();
    if (!initializer || !Node.isStringLiteral(initializer)) {
      return null;
    }

    return initializer.getLiteralValue();
  }

  /**
   * 相対パスを解決
   */
  private resolveFilePath(baseDir: string, importPath: string): string {
    const resolved = path.resolve(baseDir, importPath);
    // .ts拡張子を追加（なければ）
    return resolved.endsWith('.ts') ? resolved : `${resolved}.ts`;
  }
}
```

---

## RouteFileParser {#route-file-parser}

### 目的

各ルートファイルを解析して`server.get/post/put/delete/patch`の呼び出しを検出し、
エンドポイント情報を抽出する。

### 解析対象パターン

```typescript
// パターン1: シンプルなルート定義
server.get('/', async (req, reply) => { ... });

// パターン2: ジェネリック型付き
server.get<{ Params: { id: string } }>('/:id', async (req, reply) => { ... });

// パターン3: オプション付き
server.post<{ Body: { name: string } }>(
  '/create',
  { preHandler: [tokenVerification] },
  async (req, reply) => { ... }
);

// パターン4: 複雑な型定義
server.post<{
  Headers: CustomRequest;
  Body: { uid: string; code?: string; forceRegister?: boolean };
}>('/initialize', async (req, reply) => { ... });
```

### 実装

```typescript
// src/parsers/routeFileParser.ts

import {
  Project,
  SourceFile,
  Node,
  SyntaxKind,
  CallExpression,
  TypeLiteralNode,
} from 'ts-morph';
import type { EndpointInfo, HttpMethod, ParamInfo } from '../types';
import { HTTP_METHODS } from '../types';
import { TypeExtractor } from './typeExtractor';

export class RouteFileParser {
  private project: Project;

  constructor(tsconfigPath?: string) {
    this.project = new Project({
      tsConfigFilePath: tsconfigPath,
      skipAddingFilesFromTsConfig: true,
    });
  }

  /**
   * ルートファイルを解析してエンドポイント情報を抽出
   */
  parse(filePath: string): readonly EndpointInfo[] {
    const sourceFile = this.project.addSourceFileAtPath(filePath);
    return this.parseSourceFile(sourceFile, filePath);
  }

  /**
   * ソース文字列から解析（テスト用）
   */
  parseFromSource(source: string, filePath: string): readonly EndpointInfo[] {
    const sourceFile = this.project.createSourceFile(filePath, source, {
      overwrite: true,
    });
    return this.parseSourceFile(sourceFile, filePath);
  }

  private parseSourceFile(
    sourceFile: SourceFile,
    filePath: string
  ): readonly EndpointInfo[] {
    const typeExtractor = new TypeExtractor(sourceFile);

    // HTTPメソッド呼び出しを検出
    const methodCalls = this.findHttpMethodCalls(sourceFile);

    return methodCalls
      .map(call => this.extractEndpoint(call, typeExtractor, filePath))
      .filter((e): e is EndpointInfo => e !== null);
  }

  /**
   * server.get/post/put/delete/patch 呼び出しを検出
   */
  private findHttpMethodCalls(sourceFile: SourceFile): readonly CallExpression[] {
    const methodNames = HTTP_METHODS.map(m => m.toLowerCase());

    return sourceFile
      .getDescendantsOfKind(SyntaxKind.CallExpression)
      .filter(call => {
        const expr = call.getExpression();
        if (!Node.isPropertyAccessExpression(expr)) {
          return false;
        }
        const methodName = expr.getName().toLowerCase();
        return methodNames.includes(methodName);
      });
  }

  /**
   * メソッド呼び出しからエンドポイント情報を抽出
   */
  private extractEndpoint(
    call: CallExpression,
    typeExtractor: TypeExtractor,
    filePath: string
  ): EndpointInfo | null {
    // HTTPメソッドを取得
    const expr = call.getExpression();
    if (!Node.isPropertyAccessExpression(expr)) {
      return null;
    }
    const method = expr.getName().toUpperCase() as HttpMethod;

    // パス（第1引数）を取得
    const args = call.getArguments();
    if (args.length === 0) {
      return null;
    }

    const pathArg = args[0];
    if (!Node.isStringLiteral(pathArg)) {
      return null;
    }
    const routePath = pathArg.getLiteralValue();

    // ジェネリック型引数からパラメータ情報を抽出
    const typeArgs = call.getTypeArguments();
    const { pathParams, queryParams, bodyParams } =
      typeArgs.length > 0
        ? this.extractParamsFromTypeArg(typeArgs[0], typeExtractor, routePath)
        : {
            pathParams: this.extractPathParamsFromPath(routePath),
            queryParams: [],
            bodyParams: [],
          };

    // preHandlerからtokenVerificationを検出
    const requiresAuth = this.checkRequiresAuth(args);

    return {
      path: routePath,
      method,
      pathParams,
      queryParams,
      bodyParams,
      requiresAuth,
      sourceFile: filePath,
      lineNumber: call.getStartLineNumber(),
    };
  }

  /**
   * ジェネリック型引数からパラメータ情報を抽出
   */
  private extractParamsFromTypeArg(
    typeArg: Node,
    typeExtractor: TypeExtractor,
    routePath: string
  ): {
    pathParams: readonly ParamInfo[];
    queryParams: readonly ParamInfo[];
    bodyParams: readonly ParamInfo[];
  } {
    const type = typeArg.getType();
    const properties = type.getProperties();

    const result = {
      pathParams: [] as ParamInfo[],
      queryParams: [] as ParamInfo[],
      bodyParams: [] as ParamInfo[],
    };

    properties.forEach(prop => {
      const propName = prop.getName();
      const propType = prop.getValueDeclaration()?.getType();

      if (!propType) {
        return;
      }

      const params = typeExtractor.extractProperties(propType);

      switch (propName) {
        case 'Params':
          result.pathParams = params;
          break;
        case 'Querystring':
          result.queryParams = params;
          break;
        case 'Body':
          result.bodyParams = params;
          break;
      }
    });

    // 型定義がない場合はパスから抽出
    if (result.pathParams.length === 0) {
      result.pathParams = this.extractPathParamsFromPath(routePath);
    }

    return result;
  }

  /**
   * パス文字列から:paramを抽出
   */
  private extractPathParamsFromPath(routePath: string): readonly ParamInfo[] {
    const paramPattern = /:(\w+)/g;
    const params: ParamInfo[] = [];
    let match;

    while ((match = paramPattern.exec(routePath)) !== null) {
      params.push({
        name: match[1],
        type: 'string', // デフォルトはstring
        required: true,
      });
    }

    return params;
  }

  /**
   * preHandlerにtokenVerificationがあるかチェック
   */
  private checkRequiresAuth(args: Node[]): boolean {
    // オプションオブジェクトを探す
    const optionsArg = args.find(arg => Node.isObjectLiteralExpression(arg));
    if (!optionsArg || !Node.isObjectLiteralExpression(optionsArg)) {
      return false;
    }

    const preHandlerProp = optionsArg.getProperty('preHandler');
    if (!preHandlerProp) {
      return false;
    }

    // preHandlerの値にtokenVerificationが含まれているかチェック
    const text = preHandlerProp.getText();
    return text.includes('tokenVerification');
  }
}
```

---

## TypeExtractor {#type-extractor}

### 目的

TypeScript型から構造化されたパラメータ情報を抽出する。

### 実装

```typescript
// src/parsers/typeExtractor.ts

import { Type, SourceFile, Symbol as TsSymbol } from 'ts-morph';
import type { ParamInfo } from '../types';

export class TypeExtractor {
  constructor(private sourceFile: SourceFile) {}

  /**
   * 型からプロパティ情報を抽出
   */
  extractProperties(type: Type): readonly ParamInfo[] {
    const properties = type.getProperties();

    return properties.map(prop => this.extractPropertyInfo(prop, type));
  }

  /**
   * シンボルからプロパティ情報を抽出
   */
  private extractPropertyInfo(symbol: TsSymbol, parentType: Type): ParamInfo {
    const name = symbol.getName();
    const declaration = symbol.getValueDeclaration();

    // 型を取得
    const propType = declaration?.getType() ?? parentType.getProperty(name)?.getTypeAtLocation(this.sourceFile);
    const typeText = propType ? this.formatType(propType) : 'unknown';

    // オプショナルかどうかを判定
    const isOptional = symbol.isOptional();

    return {
      name,
      type: typeText,
      required: !isOptional,
    };
  }

  /**
   * 型を文字列表現に変換
   */
  private formatType(type: Type): string {
    // プリミティブ型
    if (type.isString()) return 'string';
    if (type.isNumber()) return 'number';
    if (type.isBoolean()) return 'boolean';
    if (type.isNull()) return 'null';
    if (type.isUndefined()) return 'undefined';

    // リテラル型
    if (type.isStringLiteral()) {
      return `'${type.getLiteralValue()}'`;
    }
    if (type.isNumberLiteral()) {
      return String(type.getLiteralValue());
    }
    if (type.isBooleanLiteral()) {
      return String(type.getLiteralValue());
    }

    // ユニオン型
    if (type.isUnion()) {
      const types = type.getUnionTypes();
      return types.map(t => this.formatType(t)).join(' | ');
    }

    // 配列型
    if (type.isArray()) {
      const elementType = type.getArrayElementType();
      if (elementType) {
        return `${this.formatType(elementType)}[]`;
      }
    }

    // オブジェクト型（インラインで表現）
    if (type.isObject() && !type.isArray()) {
      const props = type.getProperties();
      if (props.length > 0) {
        const propsText = props
          .map(p => {
            const propType = p.getValueDeclaration()?.getType();
            const typeStr = propType ? this.formatType(propType) : 'unknown';
            return `${p.getName()}: ${typeStr}`;
          })
          .join('; ');
        return `{ ${propsText}; }`;
      }
    }

    // その他（型名をそのまま使用）
    return type.getText(this.sourceFile);
  }
}
```

---

## CLIエントリーポイント {#cli-entry}

### 実装

```typescript
// index.ts

import { BuildFileParser } from './src/parsers/buildFileParser';
import { RouteFileParser } from './src/parsers/routeFileParser';
import { YamlGenerator } from './src/generators/yamlGenerator';
import type { ExtractedEndpoints, PrefixedEndpoints, ParserOptions } from './src/types';
import * as path from 'path';

export async function extractEndpoints(
  options: ParserOptions
): Promise<ExtractedEndpoints> {
  const {
    projectRoot,
    buildFilePath = 'src/build.ts',
    tsconfigPath,
    verbose = false,
  } = options;

  const fullBuildPath = path.join(projectRoot, buildFilePath);
  const fullTsconfigPath = tsconfigPath
    ? path.join(projectRoot, tsconfigPath)
    : path.join(projectRoot, 'tsconfig.json');

  if (verbose) {
    console.log(`Parsing build file: ${fullBuildPath}`);
  }

  // build.tsを解析
  const buildParser = new BuildFileParser(fullTsconfigPath);
  const registrations = buildParser.parse(fullBuildPath);

  if (verbose) {
    console.log(`Found ${registrations.length} route registrations`);
  }

  // 各ルートファイルを解析
  const routeParser = new RouteFileParser(fullTsconfigPath);
  const routes: PrefixedEndpoints[] = registrations.map(reg => {
    if (verbose) {
      console.log(`Parsing route file: ${reg.resolvedFilePath}`);
    }

    const endpoints = routeParser.parse(reg.resolvedFilePath);

    return {
      prefix: reg.prefix,
      endpoints,
    };
  });

  return {
    projectRoot,
    buildFilePath: fullBuildPath,
    routes,
    extractedAt: new Date().toISOString(),
  };
}

// CLI実行
async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.error('Usage: bun run index.ts <project-path> [--output <file>] [--verbose]');
    process.exit(1);
  }

  const projectRoot = args[0];
  const verbose = args.includes('--verbose');
  const outputIndex = args.indexOf('--output');
  const outputFile = outputIndex !== -1 ? args[outputIndex + 1] : undefined;

  try {
    const result = await extractEndpoints({
      projectRoot,
      verbose,
    });

    const generator = new YamlGenerator();
    const yaml = generator.generate(result);

    if (outputFile) {
      await Bun.write(outputFile, yaml);
      console.log(`Output written to: ${outputFile}`);
    } else {
      console.log(yaml);
    }
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

main();
```

---

## ファイル構成

```
src/
├── types/
│   ├── index.ts
│   ├── http.ts
│   ├── param.ts
│   ├── endpoint.ts
│   ├── route.ts
│   ├── output.ts
│   ├── yaml.ts
│   └── options.ts
├── parsers/
│   ├── buildFileParser.ts
│   ├── routeFileParser.ts
│   └── typeExtractor.ts
├── generators/
│   └── yamlGenerator.ts
└── __tests__/
    ├── fixtures/
    │   ├── build.fixture.ts
    │   └── route.fixture.ts
    ├── buildFileParser.test.ts
    ├── routeFileParser.test.ts
    ├── typeExtractor.test.ts
    ├── yamlGenerator.test.ts
    └── integration.test.ts
index.ts
```
