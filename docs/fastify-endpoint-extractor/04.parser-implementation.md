# パーサー実装設計

Updated: 2025/12/29 23:00

## 概要

TypeScript AST（ts-morph）を使用したFastifyエンドポイント解析の実装設計。
認証解析の改善（設定可能なミドルウェア識別子、複数フックポイント対応）を含む。

---

## ts-morph 基本概念

### Project

TypeScriptプロジェクト全体を表す。tsconfigを読み込んで型解決を行う。

```typescript
import { Project } from 'ts-morph';

const project = new Project({
  tsConfigFilePath: '/path/to/tsconfig.json',
});

// ファイルを追加
const sourceFile = project.addSourceFileAtPath('/path/to/file.ts');
```

### SourceFile

単一のTypeScriptファイルを表す。

```typescript
// import文を取得
const imports = sourceFile.getImportDeclarations();

// 関数を取得
const functions = sourceFile.getFunctions();

// 特定のパターンを検索
const callExpressions = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);
```

### AST走査パターン

```typescript
// 特定の種類のノードを全て取得
sourceFile.forEachDescendant((node) => {
  if (Node.isCallExpression(node)) {
    // CallExpressionの処理
  }
});

// 条件に合うノードを検索
const nodes = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression)
  .filter(node => {
    const expr = node.getExpression();
    return Node.isPropertyAccessExpression(expr) &&
           expr.getName() === 'register';
  });
```

---

## BuildFileParser {#build-file-parser}

### 目的

`build.ts`を解析して`app.register(Routes, { prefix })`の呼び出しを検出し、
ルートモジュールとprefixのマッピングを抽出する。

### 解析対象パターン

```typescript
// パターン1: 直接インポート
import Users from './routes/users';
app.register(Users, { prefix: '/users' });

// パターン2: 名前付きインポート
import { UsersRoutes } from './routes/users';
app.register(UsersRoutes, { prefix: '/users' });

// パターン3: 条件分岐内
if (condition) {
  app.register(Social, { prefix: '/social' });
}
```

### 実装

```typescript
// src/extractors/fastify/buildFileParser.ts

import {
  Project,
  SourceFile,
  Node,
  SyntaxKind,
  CallExpression,
} from 'ts-morph';
import type { RouteRegistration } from '../../types';
import * as path from 'path';

export class BuildFileParser {
  private project: Project;

  constructor(tsconfigPath?: string) {
    this.project = new Project({
      tsConfigFilePath: tsconfigPath,
      skipAddingFilesFromTsConfig: true,
    });
  }

  /**
   * build.tsファイルを解析してルート登録情報を抽出
   */
  parse(buildFilePath: string): readonly RouteRegistration[] {
    const sourceFile = this.project.addSourceFileAtPath(buildFilePath);
    return this.parseSourceFile(sourceFile, buildFilePath);
  }

  /**
   * ソース文字列から解析（テスト用）
   */
  parseFromSource(source: string, filePath: string): readonly RouteRegistration[] {
    const sourceFile = this.project.createSourceFile(filePath, source, {
      overwrite: true,
    });
    return this.parseSourceFile(sourceFile, filePath);
  }

  private parseSourceFile(
    sourceFile: SourceFile,
    buildFilePath: string
  ): readonly RouteRegistration[] {
    // import文からモジュール名とパスのマッピングを構築
    const importMap = this.buildImportMap(sourceFile);

    // app.register呼び出しを検出
    const registerCalls = this.findRegisterCalls(sourceFile);

    // ルート登録情報を構築
    return registerCalls
      .map(call => this.extractRegistration(call, importMap, buildFilePath))
      .filter((r): r is RouteRegistration => r !== null);
  }

  /**
   * import文からモジュール名 -> パスのマップを構築
   */
  private buildImportMap(sourceFile: SourceFile): Map<string, string> {
    const map = new Map<string, string>();

    sourceFile.getImportDeclarations().forEach(imp => {
      const moduleSpecifier = imp.getModuleSpecifierValue();

      // デフォルトインポート
      const defaultImport = imp.getDefaultImport();
      if (defaultImport) {
        map.set(defaultImport.getText(), moduleSpecifier);
      }

      // 名前付きインポート
      imp.getNamedImports().forEach(named => {
        const name = named.getAliasNode()?.getText() ?? named.getName();
        map.set(name, moduleSpecifier);
      });
    });

    return map;
  }

  /**
   * app.register / server.register 呼び出しを検出
   */
  private findRegisterCalls(sourceFile: SourceFile): readonly CallExpression[] {
    return sourceFile
      .getDescendantsOfKind(SyntaxKind.CallExpression)
      .filter(call => {
        const expr = call.getExpression();
        if (!Node.isPropertyAccessExpression(expr)) {
          return false;
        }
        return expr.getName() === 'register';
      });
  }

  /**
   * register呼び出しからルート登録情報を抽出
   */
  private extractRegistration(
    call: CallExpression,
    importMap: Map<string, string>,
    buildFilePath: string
  ): RouteRegistration | null {
    const args = call.getArguments();
    if (args.length < 2) {
      return null;
    }

    // 第1引数: ルートモジュール
    const moduleArg = args[0];
    const importName = moduleArg.getText();
    const importPath = importMap.get(importName);

    if (!importPath) {
      return null;
    }

    // 第2引数: オプション { prefix: '...' }
    const optionsArg = args[1];
    const prefix = this.extractPrefix(optionsArg);

    if (!prefix) {
      return null;
    }

    // ファイルパスを解決
    const buildDir = path.dirname(buildFilePath);
    const resolvedFilePath = this.resolveFilePath(buildDir, importPath);

    return {
      importName,
      importPath,
      prefix,
      resolvedFilePath,
    };
  }

  /**
   * オプションオブジェクトからprefixを抽出
   */
  private extractPrefix(optionsNode: Node): string | null {
    if (!Node.isObjectLiteralExpression(optionsNode)) {
      return null;
    }

    const prefixProp = optionsNode.getProperty('prefix');
    if (!prefixProp || !Node.isPropertyAssignment(prefixProp)) {
      return null;
    }

    const initializer = prefixProp.getInitializer();
    if (!initializer || !Node.isStringLiteral(initializer)) {
      return null;
    }

    return initializer.getLiteralValue();
  }

  /**
   * 相対パスを解決
   */
  private resolveFilePath(baseDir: string, importPath: string): string {
    const resolved = path.resolve(baseDir, importPath);
    // .ts拡張子を追加（なければ）
    return resolved.endsWith('.ts') ? resolved : `${resolved}.ts`;
  }
}
```

---

## RouteFileParser {#route-file-parser}

### 目的

各ルートファイルを解析して`server.get/post/put/delete/patch`の呼び出しを検出し、
エンドポイント情報を抽出する。

### 解析対象パターン

```typescript
// パターン1: シンプルなルート定義
server.get('/', async (req, reply) => { ... });

// パターン2: ジェネリック型付き
server.get<{ Params: { id: string } }>('/:id', async (req, reply) => { ... });

// パターン3: オプション付き（preHandler）
server.post<{ Body: { name: string } }>(
  '/create',
  { preHandler: [tokenVerification] },
  async (req, reply) => { ... }
);

// パターン4: onRequestフック
server.get(
  '/protected',
  { onRequest: [authenticate] },
  async (req, reply) => { ... }
);

// パターン5: 複数のフック
server.post(
  '/admin',
  {
    onRequest: [authenticate],
    preHandler: [adminOnly, rateLimiter]
  },
  async (req, reply) => { ... }
);

// パターン6: 複雑な型定義
server.post<{
  Headers: CustomRequest;
  Body: { uid: string; code?: string; forceRegister?: boolean };
}>('/initialize', async (req, reply) => { ... });
```

### 実装（認証解析改善版）

```typescript
// src/extractors/fastify/routeFileParser.ts

import {
  Project,
  SourceFile,
  Node,
  SyntaxKind,
  CallExpression,
} from 'ts-morph';
import type { EndpointInfo, HttpMethod, ParamInfo, AuthConfig, AuthInfo } from '../../types';
import { HTTP_METHODS, DEFAULT_AUTH_CONFIG } from '../../types';
import { TypeExtractor } from '../../core/typeExtractor';
import { AuthDetector } from './authDetector';

export class RouteFileParser {
  private project: Project;
  private authDetector: AuthDetector;

  constructor(tsconfigPath?: string, authConfig: AuthConfig = DEFAULT_AUTH_CONFIG) {
    this.project = new Project({
      tsConfigFilePath: tsconfigPath,
      skipAddingFilesFromTsConfig: true,
    });
    this.authDetector = new AuthDetector(authConfig);
  }

  /**
   * ルートファイルを解析してエンドポイント情報を抽出
   */
  parse(filePath: string): readonly EndpointInfo[] {
    const sourceFile = this.project.addSourceFileAtPath(filePath);
    return this.parseSourceFile(sourceFile, filePath);
  }

  /**
   * ソース文字列から解析（テスト用）
   */
  parseFromSource(source: string, filePath: string): readonly EndpointInfo[] {
    const sourceFile = this.project.createSourceFile(filePath, source, {
      overwrite: true,
    });
    return this.parseSourceFile(sourceFile, filePath);
  }

  private parseSourceFile(
    sourceFile: SourceFile,
    filePath: string
  ): readonly EndpointInfo[] {
    const typeExtractor = new TypeExtractor(sourceFile);

    // HTTPメソッド呼び出しを検出
    const methodCalls = this.findHttpMethodCalls(sourceFile);

    return methodCalls
      .map(call => this.extractEndpoint(call, typeExtractor, filePath))
      .filter((e): e is EndpointInfo => e !== null);
  }

  /**
   * server.get/post/put/delete/patch 呼び出しを検出
   */
  private findHttpMethodCalls(sourceFile: SourceFile): readonly CallExpression[] {
    const methodNames = HTTP_METHODS.map(m => m.toLowerCase());

    return sourceFile
      .getDescendantsOfKind(SyntaxKind.CallExpression)
      .filter(call => {
        const expr = call.getExpression();
        if (!Node.isPropertyAccessExpression(expr)) {
          return false;
        }
        const methodName = expr.getName().toLowerCase();
        return methodNames.includes(methodName);
      });
  }

  /**
   * メソッド呼び出しからエンドポイント情報を抽出
   */
  private extractEndpoint(
    call: CallExpression,
    typeExtractor: TypeExtractor,
    filePath: string
  ): EndpointInfo | null {
    // HTTPメソッドを取得
    const expr = call.getExpression();
    if (!Node.isPropertyAccessExpression(expr)) {
      return null;
    }
    const method = expr.getName().toUpperCase() as HttpMethod;

    // パス（第1引数）を取得
    const args = call.getArguments();
    if (args.length === 0) {
      return null;
    }

    const pathArg = args[0];
    if (!Node.isStringLiteral(pathArg)) {
      return null;
    }
    const routePath = pathArg.getLiteralValue();

    // ジェネリック型引数からパラメータ情報を抽出
    const typeArgs = call.getTypeArguments();
    const { pathParams, queryParams, bodyParams } =
      typeArgs.length > 0
        ? this.extractParamsFromTypeArg(typeArgs[0], typeExtractor, routePath)
        : {
            pathParams: this.extractPathParamsFromPath(routePath),
            queryParams: [],
            bodyParams: [],
          };

    // 認証情報を抽出（改善版）
    const auth = this.authDetector.detect(args);

    return {
      path: routePath,
      method,
      pathParams,
      queryParams,
      bodyParams,
      auth,
      sourceFile: filePath,
      lineNumber: call.getStartLineNumber(),
    };
  }

  /**
   * ジェネリック型引数からパラメータ情報を抽出
   */
  private extractParamsFromTypeArg(
    typeArg: Node,
    typeExtractor: TypeExtractor,
    routePath: string
  ): {
    pathParams: readonly ParamInfo[];
    queryParams: readonly ParamInfo[];
    bodyParams: readonly ParamInfo[];
  } {
    const type = typeArg.getType();
    const properties = type.getProperties();

    const result = {
      pathParams: [] as ParamInfo[],
      queryParams: [] as ParamInfo[],
      bodyParams: [] as ParamInfo[],
    };

    properties.forEach(prop => {
      const propName = prop.getName();
      const propType = prop.getValueDeclaration()?.getType();

      if (!propType) {
        return;
      }

      const params = typeExtractor.extractProperties(propType);

      switch (propName) {
        case 'Params':
          result.pathParams = params;
          break;
        case 'Querystring':
          result.queryParams = params;
          break;
        case 'Body':
          result.bodyParams = params;
          break;
      }
    });

    // 型定義がない場合はパスから抽出
    if (result.pathParams.length === 0) {
      result.pathParams = this.extractPathParamsFromPath(routePath);
    }

    return result;
  }

  /**
   * パス文字列から:paramを抽出
   */
  private extractPathParamsFromPath(routePath: string): readonly ParamInfo[] {
    const paramPattern = /:(\w+)/g;
    const params: ParamInfo[] = [];
    let match: RegExpExecArray | null;

    while ((match = paramPattern.exec(routePath)) !== null) {
      params.push({
        name: match[1],
        type: 'string', // デフォルトはstring
        required: true,
      });
    }

    return params;
  }
}
```

---

## AuthDetector {#auth-detector}

### 目的

Fastifyルート定義から認証ミドルウェアを検出する。
設定可能な識別子リストと複数のフックポイントに対応。

### 解析対象パターン

```typescript
// パターン1: preHandler配列
{ preHandler: [tokenVerification] }

// パターン2: preHandler単一
{ preHandler: tokenVerification }

// パターン3: onRequest
{ onRequest: [authenticate] }

// パターン4: preValidation
{ preValidation: [authGuard] }

// パターン5: 複数フック
{
  onRequest: [authenticate],
  preHandler: [adminOnly]
}

// パターン6: カスタム認証関数
{ preHandler: [customAuthMiddleware] }
```

### 実装

```typescript
// src/extractors/fastify/authDetector.ts

import { Node, SyntaxKind } from 'ts-morph';
import type { AuthConfig, AuthInfo, FastifyAuthHook } from '../../types';

export class AuthDetector {
  constructor(private config: AuthConfig) {}

  /**
   * ルート定義の引数から認証情報を検出
   */
  detect(args: Node[]): AuthInfo {
    // オプションオブジェクトを探す
    const optionsArg = args.find(arg => Node.isObjectLiteralExpression(arg));

    if (!optionsArg || !Node.isObjectLiteralExpression(optionsArg)) {
      return { required: false, middlewares: [] };
    }

    // 各フックポイントをチェック
    for (const hookPoint of this.config.hookPoints) {
      const hookProp = optionsArg.getProperty(hookPoint);

      if (!hookProp) {
        continue;
      }

      const detectedMiddlewares = this.extractMiddlewareNames(hookProp);
      const authMiddlewares = this.filterAuthMiddlewares(detectedMiddlewares);

      if (authMiddlewares.length > 0) {
        return {
          required: true,
          middlewares: authMiddlewares,
          hookPoint,
        };
      }
    }

    return { required: false, middlewares: [] };
  }

  /**
   * フックプロパティからミドルウェア名を抽出
   */
  private extractMiddlewareNames(hookProp: Node): readonly string[] {
    const middlewares: string[] = [];

    // 配列形式: { preHandler: [tokenVerification, anotherMiddleware] }
    // 単一形式: { preHandler: tokenVerification }

    hookProp.forEachDescendant(node => {
      if (Node.isIdentifier(node)) {
        const name = node.getText();
        // プロパティ名自体は除外
        if (!this.isHookPointName(name) && !this.isReservedKeyword(name)) {
          middlewares.push(name);
        }
      }
    });

    return middlewares;
  }

  /**
   * 認証ミドルウェアをフィルタリング
   */
  private filterAuthMiddlewares(middlewares: readonly string[]): readonly string[] {
    return middlewares.filter(name => this.isAuthMiddleware(name));
  }

  /**
   * 認証ミドルウェアか判定（部分一致）
   */
  isAuthMiddleware(name: string): boolean {
    const lowerName = name.toLowerCase();
    return this.config.middlewareNames.some(
      authName => lowerName.includes(authName.toLowerCase())
    );
  }

  /**
   * フックポイント名か判定
   */
  private isHookPointName(name: string): boolean {
    const hookNames: readonly string[] = [
      'preHandler',
      'onRequest',
      'preValidation',
      'preParsing',
      'preSerialization',
      'onSend',
      'onResponse',
      'onError',
      'onTimeout',
    ];
    return hookNames.includes(name);
  }

  /**
   * 予約語・キーワードか判定
   */
  private isReservedKeyword(name: string): boolean {
    const reserved = ['async', 'await', 'function', 'const', 'let', 'var'];
    return reserved.includes(name);
  }
}
```

### 設定例

```typescript
// カスタム認証設定
const customAuthConfig: AuthConfig = {
  middlewareNames: [
    'tokenVerification',    // 既存
    'authenticate',         // 既存
    'customAuth',           // プロジェクト固有
    'adminOnly',            // プロジェクト固有
    'roleGuard',            // プロジェクト固有
  ],
  hookPoints: ['preHandler', 'onRequest', 'preValidation'],
};

const parser = new RouteFileParser(tsconfigPath, customAuthConfig);
```

---

## TypeExtractor {#type-extractor}

### 目的

TypeScript型から構造化されたパラメータ情報を抽出する。
共通基盤として全フレームワークで使用。

### 実装

```typescript
// src/core/typeExtractor.ts

import { Type, SourceFile, Symbol as TsSymbol } from 'ts-morph';
import type { ParamInfo } from '../types';

export class TypeExtractor {
  constructor(private sourceFile: SourceFile) {}

  /**
   * 型からプロパティ情報を抽出
   */
  extractProperties(type: Type): readonly ParamInfo[] {
    const properties = type.getProperties();

    return properties.map(prop => this.extractPropertyInfo(prop, type));
  }

  /**
   * シンボルからプロパティ情報を抽出
   */
  private extractPropertyInfo(symbol: TsSymbol, parentType: Type): ParamInfo {
    const name = symbol.getName();
    const declaration = symbol.getValueDeclaration();

    // 型を取得
    const propType = declaration?.getType() ?? parentType.getProperty(name)?.getTypeAtLocation(this.sourceFile);
    const typeText = propType ? this.formatType(propType) : 'unknown';

    // オプショナルかどうかを判定
    const isOptional = symbol.isOptional();

    return {
      name,
      type: typeText,
      required: !isOptional,
    };
  }

  /**
   * 型を文字列表現に変換
   */
  private formatType(type: Type): string {
    // プリミティブ型
    if (type.isString()) return 'string';
    if (type.isNumber()) return 'number';
    if (type.isBoolean()) return 'boolean';
    if (type.isNull()) return 'null';
    if (type.isUndefined()) return 'undefined';

    // リテラル型
    if (type.isStringLiteral()) {
      return `'${type.getLiteralValue()}'`;
    }
    if (type.isNumberLiteral()) {
      return String(type.getLiteralValue());
    }
    if (type.isBooleanLiteral()) {
      return String(type.getLiteralValue());
    }

    // ユニオン型
    if (type.isUnion()) {
      const types = type.getUnionTypes();
      return types.map(t => this.formatType(t)).join(' | ');
    }

    // 配列型
    if (type.isArray()) {
      const elementType = type.getArrayElementType();
      if (elementType) {
        return `${this.formatType(elementType)}[]`;
      }
    }

    // オブジェクト型（インラインで表現）
    if (type.isObject() && !type.isArray()) {
      const props = type.getProperties();
      if (props.length > 0) {
        const propsText = props
          .map(p => {
            const propType = p.getValueDeclaration()?.getType();
            const typeStr = propType ? this.formatType(propType) : 'unknown';
            return `${p.getName()}: ${typeStr}`;
          })
          .join('; ');
        return `{ ${propsText}; }`;
      }
    }

    // その他（型名をそのまま使用）
    return type.getText(this.sourceFile);
  }
}
```

---

## ファイル構成（更新版）

```
src/
├── types/
│   ├── index.ts
│   ├── framework.ts       # NEW: フレームワーク型
│   ├── http.ts
│   ├── param.ts
│   ├── auth.ts            # NEW: 認証設定型
│   ├── endpoint.ts        # UPDATED: AuthInfo追加
│   ├── route.ts
│   ├── output.ts          # UPDATED: framework, 統計追加
│   ├── yaml.ts
│   └── options.ts         # UPDATED: authConfig追加
│
├── core/                   # NEW: 共通基盤
│   ├── typeExtractor.ts    # MOVED from parsers/
│   ├── frameworkDetector.ts
│   └── extractorFactory.ts
│
├── extractors/             # NEW: フレームワーク固有
│   ├── types.ts            # EndpointExtractorインターフェース
│   └── fastify/
│       ├── index.ts        # FastifyExtractor
│       ├── buildFileParser.ts
│       ├── routeFileParser.ts
│       └── authDetector.ts  # NEW: 認証検出
│
├── generators/
│   └── yamlGenerator.ts
│
└── __tests__/
    ├── fixtures/
    │   ├── build.fixture.ts
    │   ├── route.fixture.ts
    │   └── auth.fixture.ts  # NEW: 認証テスト用
    ├── buildFileParser.test.ts
    ├── routeFileParser.test.ts
    ├── typeExtractor.test.ts
    ├── authDetector.test.ts  # NEW
    ├── frameworkDetector.test.ts  # NEW
    ├── yamlGenerator.test.ts
    └── integration.test.ts
index.ts
```

---

## 認証解析の改善まとめ

### Before（旧実装）

```typescript
// ハードコードされた文字列チェック
private checkRequiresAuth(args: Node[]): boolean {
  const text = preHandlerProp.getText();
  return text.includes('tokenVerification');  // 固定値
}
```

**問題点:**
- `tokenVerification`のみ検出
- `preHandler`フックのみ対応
- プロジェクト固有の認証関数に対応不可

### After（改善版）

```typescript
// 設定可能な認証検出
const authDetector = new AuthDetector({
  middlewareNames: ['tokenVerification', 'authGuard', 'customAuth'],
  hookPoints: ['preHandler', 'onRequest', 'preValidation'],
});

const auth = authDetector.detect(args);
// => { required: true, middlewares: ['tokenVerification'], hookPoint: 'preHandler' }
```

**改善点:**
- 認証ミドルウェア名を設定可能
- 複数のフックポイントに対応
- 検出されたミドルウェア名を保持
- 部分一致による柔軟なマッチング
