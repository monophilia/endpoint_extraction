# テスト設計

Updated: 2025/12/29 21:50

## 概要

各パーサーとジェネレーターのテストケースを定義する。
TDD原則に基づき、実装前にテストを作成する。

## テストフレームワーク

Bunの組み込みテストランナーを使用。

```typescript
import { describe, it, expect } from 'bun:test';
```

---

## BuildFileParser テスト {#build-file-parser}

### テストファイル

`src/__tests__/buildFileParser.test.ts`

### テスト用フィクスチャ

```typescript
// src/__tests__/fixtures/build.fixture.ts

export const SIMPLE_BUILD = `
import Users from './routes/users';
import Rooms from './routes/rooms';
import fastify from 'fastify';

export const build = async () => {
  const app = fastify();
  app.register(Users, { prefix: '/users' });
  app.register(Rooms, { prefix: '/getRooms' });
  return app;
};
`;

export const CONDITIONAL_BUILD = `
import Users from './routes/users';
import Social from './routes/social';
import fastify from 'fastify';

export const build = async () => {
  const app = fastify();
  app.register(Users, { prefix: '/users' });

  if (process.env.NODE_ENV !== 'test') {
    app.register(Social, { prefix: '/social' });
  }

  return app;
};
`;

export const NO_ROUTES_BUILD = `
import fastify from 'fastify';

export const build = async () => {
  const app = fastify();
  return app;
};
`;
```

### テストケース

```typescript
// src/__tests__/buildFileParser.test.ts

import { describe, it, expect } from 'bun:test';
import { BuildFileParser } from '../parsers/buildFileParser';
import { SIMPLE_BUILD, CONDITIONAL_BUILD, NO_ROUTES_BUILD } from './fixtures/build.fixture';

describe('BuildFileParser', () => {
  describe('parseRouteRegistrations', () => {
    it('app.register呼び出しからルート登録情報を抽出できる', () => {
      const parser = new BuildFileParser();
      const result = parser.parseFromSource(SIMPLE_BUILD, '/project/src/build.ts');

      expect(result).toHaveLength(2);
      expect(result[0]).toEqual({
        importName: 'Users',
        importPath: './routes/users',
        prefix: '/users',
        resolvedFilePath: '/project/src/routes/users.ts',
      });
      expect(result[1]).toEqual({
        importName: 'Rooms',
        importPath: './routes/rooms',
        prefix: '/getRooms',
        resolvedFilePath: '/project/src/routes/rooms.ts',
      });
    });

    it('条件分岐内のルート登録も抽出できる', () => {
      const parser = new BuildFileParser();
      const result = parser.parseFromSource(CONDITIONAL_BUILD, '/project/src/build.ts');

      expect(result).toHaveLength(2);
      expect(result.map(r => r.prefix)).toContain('/users');
      expect(result.map(r => r.prefix)).toContain('/social');
    });

    it('ルート登録がない場合は空配列を返す', () => {
      const parser = new BuildFileParser();
      const result = parser.parseFromSource(NO_ROUTES_BUILD, '/project/src/build.ts');

      expect(result).toHaveLength(0);
    });

    it('prefixオプションがない場合はスキップする', () => {
      const source = `
        import Users from './routes/users';
        const app = fastify();
        app.register(Users); // prefixなし
      `;
      const parser = new BuildFileParser();
      const result = parser.parseFromSource(source, '/project/src/build.ts');

      expect(result).toHaveLength(0);
    });
  });
});
```

---

## RouteFileParser テスト {#route-file-parser}

### テストファイル

`src/__tests__/routeFileParser.test.ts`

### テスト用フィクスチャ

```typescript
// src/__tests__/fixtures/route.fixture.ts

export const SIMPLE_ROUTE = `
import { FastifyInstance } from 'fastify';

export default (server: FastifyInstance, opts: any, next: () => void): void => {
  server.get('/', async (req, reply) => {
    reply.send({ message: 'Hello' });
  });

  next();
};
`;

export const TYPED_ROUTE = `
import { FastifyInstance } from 'fastify';
import { tokenVerification } from '../middleware/tokenVerification';

export default (server: FastifyInstance, opts: any, next: () => void): void => {
  server.get<{ Params: { id: string } }>(
    '/:id',
    { preHandler: [tokenVerification] },
    async (req, reply) => {
      reply.send({ id: req.params.id });
    }
  );

  server.post<{
    Body: { name: string; email?: string };
    Querystring: { force?: boolean };
  }>('/create', async (req, reply) => {
    reply.send({ created: true });
  });

  next();
};
`;

export const ALL_METHODS_ROUTE = `
import { FastifyInstance } from 'fastify';

export default (server: FastifyInstance, opts: any, next: () => void): void => {
  server.get('/resource', async () => {});
  server.post('/resource', async () => {});
  server.put('/resource/:id', async () => {});
  server.delete('/resource/:id', async () => {});
  server.patch('/resource/:id', async () => {});

  next();
};
`;
```

### テストケース

```typescript
// src/__tests__/routeFileParser.test.ts

import { describe, it, expect } from 'bun:test';
import { RouteFileParser } from '../parsers/routeFileParser';
import { SIMPLE_ROUTE, TYPED_ROUTE, ALL_METHODS_ROUTE } from './fixtures/route.fixture';

describe('RouteFileParser', () => {
  describe('parseEndpoints', () => {
    it('基本的なGETエンドポイントを抽出できる', () => {
      const parser = new RouteFileParser();
      const result = parser.parseFromSource(SIMPLE_ROUTE, 'routes/test.ts');

      expect(result).toHaveLength(1);
      expect(result[0].path).toBe('/');
      expect(result[0].method).toBe('GET');
      expect(result[0].requiresAuth).toBe(false);
    });

    it('ジェネリック型からパラメータ情報を抽出できる', () => {
      const parser = new RouteFileParser();
      const result = parser.parseFromSource(TYPED_ROUTE, 'routes/test.ts');

      const getEndpoint = result.find(e => e.method === 'GET');
      expect(getEndpoint).toBeDefined();
      expect(getEndpoint!.path).toBe('/:id');
      expect(getEndpoint!.pathParams).toHaveLength(1);
      expect(getEndpoint!.pathParams[0]).toEqual({
        name: 'id',
        type: 'string',
        required: true,
      });
      expect(getEndpoint!.requiresAuth).toBe(true);

      const postEndpoint = result.find(e => e.method === 'POST');
      expect(postEndpoint).toBeDefined();
      expect(postEndpoint!.bodyParams).toHaveLength(2);
      expect(postEndpoint!.bodyParams.find(p => p.name === 'name')).toEqual({
        name: 'name',
        type: 'string',
        required: true,
      });
      expect(postEndpoint!.bodyParams.find(p => p.name === 'email')).toEqual({
        name: 'email',
        type: 'string',
        required: false,
      });
      expect(postEndpoint!.queryParams).toHaveLength(1);
    });

    it('全HTTPメソッドを認識できる', () => {
      const parser = new RouteFileParser();
      const result = parser.parseFromSource(ALL_METHODS_ROUTE, 'routes/test.ts');

      expect(result).toHaveLength(5);
      const methods = result.map(e => e.method);
      expect(methods).toContain('GET');
      expect(methods).toContain('POST');
      expect(methods).toContain('PUT');
      expect(methods).toContain('DELETE');
      expect(methods).toContain('PATCH');
    });

    it('パスからパスパラメータ名を抽出できる', () => {
      const parser = new RouteFileParser();
      const result = parser.parseFromSource(ALL_METHODS_ROUTE, 'routes/test.ts');

      const putEndpoint = result.find(e => e.method === 'PUT');
      expect(putEndpoint!.path).toBe('/resource/:id');
      // パス文字列からも:idを検出（型定義がなくても）
    });
  });
});
```

---

## TypeExtractor テスト {#type-extractor}

### テストファイル

`src/__tests__/typeExtractor.test.ts`

### テストケース

```typescript
// src/__tests__/typeExtractor.test.ts

import { describe, it, expect } from 'bun:test';
import { TypeExtractor } from '../parsers/typeExtractor';
import { Project } from 'ts-morph';

describe('TypeExtractor', () => {
  const createProject = (source: string) => {
    const project = new Project({ useInMemoryFileSystem: true });
    return project.createSourceFile('test.ts', source);
  };

  describe('extractFromTypeLiteral', () => {
    it('型リテラルからプロパティを抽出できる', () => {
      const source = `
        type Test = { name: string; age: number };
      `;
      const sourceFile = createProject(source);
      const extractor = new TypeExtractor(sourceFile);

      const typeAlias = sourceFile.getTypeAliasOrThrow('Test');
      const result = extractor.extractProperties(typeAlias.getType());

      expect(result).toHaveLength(2);
      expect(result).toContainEqual({ name: 'name', type: 'string', required: true });
      expect(result).toContainEqual({ name: 'age', type: 'number', required: true });
    });

    it('オプショナルプロパティを正しく判定できる', () => {
      const source = `
        type Test = {
          required: string;
          optional?: number;
        };
      `;
      const sourceFile = createProject(source);
      const extractor = new TypeExtractor(sourceFile);

      const typeAlias = sourceFile.getTypeAliasOrThrow('Test');
      const result = extractor.extractProperties(typeAlias.getType());

      expect(result.find(p => p.name === 'required')!.required).toBe(true);
      expect(result.find(p => p.name === 'optional')!.required).toBe(false);
    });

    it('ユニオン型を文字列表現できる', () => {
      const source = `
        type Test = {
          status: 'active' | 'inactive';
          value: string | number;
        };
      `;
      const sourceFile = createProject(source);
      const extractor = new TypeExtractor(sourceFile);

      const typeAlias = sourceFile.getTypeAliasOrThrow('Test');
      const result = extractor.extractProperties(typeAlias.getType());

      expect(result.find(p => p.name === 'status')!.type).toBe("'active' | 'inactive'");
      expect(result.find(p => p.name === 'value')!.type).toBe('string | number');
    });

    it('ネストされたオブジェクト型を扱える', () => {
      const source = `
        type Test = {
          user: { name: string; id: number };
        };
      `;
      const sourceFile = createProject(source);
      const extractor = new TypeExtractor(sourceFile);

      const typeAlias = sourceFile.getTypeAliasOrThrow('Test');
      const result = extractor.extractProperties(typeAlias.getType());

      expect(result.find(p => p.name === 'user')!.type).toBe('{ name: string; id: number; }');
    });

    it('配列型を扱える', () => {
      const source = `
        type Test = {
          items: string[];
          users: Array<{ id: number }>;
        };
      `;
      const sourceFile = createProject(source);
      const extractor = new TypeExtractor(sourceFile);

      const typeAlias = sourceFile.getTypeAliasOrThrow('Test');
      const result = extractor.extractProperties(typeAlias.getType());

      expect(result.find(p => p.name === 'items')!.type).toBe('string[]');
    });
  });
});
```

---

## YamlGenerator テスト {#yaml-generator}

### テストファイル

`src/__tests__/yamlGenerator.test.ts`

### テストケース

```typescript
// src/__tests__/yamlGenerator.test.ts

import { describe, it, expect } from 'bun:test';
import { YamlGenerator } from '../generators/yamlGenerator';
import type { ExtractedEndpoints } from '../types';

describe('YamlGenerator', () => {
  describe('generate', () => {
    it('単一エンドポイントをYAML形式で出力できる', () => {
      const input: ExtractedEndpoints = {
        projectRoot: '/project',
        buildFilePath: '/project/src/build.ts',
        routes: [
          {
            prefix: '/users',
            endpoints: [
              {
                path: '/:id',
                method: 'GET',
                pathParams: [{ name: 'id', type: 'string', required: true }],
                queryParams: [],
                bodyParams: [],
                requiresAuth: true,
                sourceFile: 'routes/users.ts',
                lineNumber: 10,
              },
            ],
          },
        ],
        extractedAt: '2025-12-29T12:00:00.000Z',
      };

      const generator = new YamlGenerator();
      const result = generator.generate(input);

      expect(result).toContain('/users:');
      expect(result).toContain('endpoints:');
      expect(result).toContain('/:id:');
      expect(result).toContain('METHOD: GET');
      expect(result).toContain('pathParams:');
      expect(result).toContain('id: string');
      expect(result).toContain('requiresAuth: true');
    });

    it('複数prefixのルートを出力できる', () => {
      const input: ExtractedEndpoints = {
        projectRoot: '/project',
        buildFilePath: '/project/src/build.ts',
        routes: [
          {
            prefix: '/users',
            endpoints: [
              {
                path: '/',
                method: 'GET',
                pathParams: [],
                queryParams: [],
                bodyParams: [],
                requiresAuth: false,
                sourceFile: 'routes/users.ts',
                lineNumber: 5,
              },
            ],
          },
          {
            prefix: '/rooms',
            endpoints: [
              {
                path: '/',
                method: 'POST',
                pathParams: [],
                queryParams: [],
                bodyParams: [{ name: 'name', type: 'string', required: true }],
                requiresAuth: true,
                sourceFile: 'routes/rooms.ts',
                lineNumber: 10,
              },
            ],
          },
        ],
        extractedAt: '2025-12-29T12:00:00.000Z',
      };

      const generator = new YamlGenerator();
      const result = generator.generate(input);

      expect(result).toContain('/users:');
      expect(result).toContain('/rooms:');
    });

    it('パラメータがない場合はそのセクションを省略する', () => {
      const input: ExtractedEndpoints = {
        projectRoot: '/project',
        buildFilePath: '/project/src/build.ts',
        routes: [
          {
            prefix: '/health',
            endpoints: [
              {
                path: '/',
                method: 'GET',
                pathParams: [],
                queryParams: [],
                bodyParams: [],
                requiresAuth: false,
                sourceFile: 'routes/health.ts',
                lineNumber: 1,
              },
            ],
          },
        ],
        extractedAt: '2025-12-29T12:00:00.000Z',
      };

      const generator = new YamlGenerator();
      const result = generator.generate(input);

      expect(result).not.toContain('pathParams:');
      expect(result).not.toContain('queryParams:');
      expect(result).not.toContain('bodyParams:');
    });

    it('オプショナルパラメータの型表現が正しい', () => {
      const input: ExtractedEndpoints = {
        projectRoot: '/project',
        buildFilePath: '/project/src/build.ts',
        routes: [
          {
            prefix: '/api',
            endpoints: [
              {
                path: '/search',
                method: 'GET',
                pathParams: [],
                queryParams: [
                  { name: 'q', type: 'string', required: true },
                  { name: 'limit', type: 'number', required: false },
                ],
                bodyParams: [],
                requiresAuth: false,
                sourceFile: 'routes/api.ts',
                lineNumber: 1,
              },
            ],
          },
        ],
        extractedAt: '2025-12-29T12:00:00.000Z',
      };

      const generator = new YamlGenerator();
      const result = generator.generate(input);

      expect(result).toContain('q: string');
      expect(result).toContain('limit: number | undefined');
    });
  });
});
```

---

## 統合テスト

### テストファイル

`src/__tests__/integration.test.ts`

### テストケース

```typescript
// src/__tests__/integration.test.ts

import { describe, it, expect } from 'bun:test';
import { extractEndpoints } from '../index';
import * as path from 'path';

describe('Integration', () => {
  it('実際のFastifyプロジェクトからエンドポイントを抽出できる', async () => {
    const projectRoot = '/Users/issei/program/ts_work/web/react/voice-app-test/server';

    const result = await extractEndpoints({
      projectRoot,
      buildFilePath: 'src/build.ts',
    });

    // 基本構造の確認
    expect(result.projectRoot).toBe(projectRoot);
    expect(result.routes.length).toBeGreaterThan(0);

    // /usersルートの確認
    const usersRoute = result.routes.find(r => r.prefix === '/users');
    expect(usersRoute).toBeDefined();
    expect(usersRoute!.endpoints.length).toBeGreaterThan(0);

    // エンドポイントの詳細確認
    const initializeEndpoint = usersRoute!.endpoints.find(
      e => e.path === '/initialize' && e.method === 'POST'
    );
    expect(initializeEndpoint).toBeDefined();
    expect(initializeEndpoint!.bodyParams.length).toBeGreaterThan(0);
  });
});
```

---

## テスト実行方法

```bash
# 全テスト実行
bun test

# 特定ファイルのテスト
bun test src/__tests__/buildFileParser.test.ts

# watchモード
bun test --watch
```

---

## テストカバレッジ目標

| モジュール | カバレッジ目標 |
|-----------|--------------|
| BuildFileParser | 90%以上 |
| RouteFileParser | 90%以上 |
| TypeExtractor | 85%以上 |
| YamlGenerator | 95%以上 |
