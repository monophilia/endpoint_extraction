# 実装設計 - ResponseExtractor

Updated: 2025/12/30 06:15

## 目的

Fastifyハンドラー関数からレスポンス型を抽出するResponseExtractorクラスを設計する。

---

## Fastifyレスポンスパターン分析

### パターン1: シンプルなreturn

```typescript
server.get('/users', async (req, reply) => {
  return { users: [], total: 0 };  // 暗黙の200
});
```

### パターン2: reply.send()

```typescript
server.get('/users/:id', async (req, reply) => {
  const user = await findUser(id);
  reply.send(user);  // 暗黙の200
});
```

### パターン3: ステータスコード指定

```typescript
server.post('/users', async (req, reply) => {
  const user = await createUser(req.body);
  reply.code(201).send(user);  // 明示的な201
});
```

### パターン4: エラーレスポンス

```typescript
server.get('/users/:id', async (req, reply) => {
  const user = await findUser(id);
  if (!user) {
    reply.code(404).send({ error: 'User not found' });
    return;
  }
  return user;
});
```

### パターン5: ジェネリック型定義（Reply型）

```typescript
server.get<{
  Params: { id: string };
  Reply: UserResponse | ErrorResponse;
}>('/users/:id', async (req, reply) => {
  // ...
});
```

---

## ResponseExtractorクラス設計

### ファイル配置

```
src/extractors/fastify/responseExtractor.ts
```

### クラス構造

```typescript
// src/extractors/fastify/responseExtractor.ts

import {
  SourceFile,
  Node,
  SyntaxKind,
  CallExpression,
  ArrowFunction,
  FunctionExpression,
} from 'ts-morph';
import type { EndpointResponses, ResponseInfo, ErrorResponseInfo, ParamInfo } from '../../types';
import { TypeExtractor } from '../../core/typeExtractor';

export class ResponseExtractor {
  private readonly typeExtractor: TypeExtractor;

  constructor(private readonly sourceFile: SourceFile) {
    this.typeExtractor = new TypeExtractor(sourceFile);
  }

  /**
   * ハンドラー関数からレスポンス情報を抽出
   */
  extractFromHandler(handlerNode: ArrowFunction | FunctionExpression): EndpointResponses {
    const successResponses: ResponseInfo[] = [];
    const errorResponses: ErrorResponseInfo[] = [];

    // 1. return文を検索
    this.extractReturnStatements(handlerNode, successResponses);

    // 2. reply.send() / reply.code().send() を検索
    this.extractReplySendCalls(handlerNode, successResponses, errorResponses);

    // 3. 重複除去・正規化
    return {
      success: this.deduplicateResponses(successResponses),
      errors: this.deduplicateErrors(errorResponses),
    };
  }

  /**
   * ジェネリック型からレスポンス情報を抽出
   */
  extractFromGenericType(call: CallExpression): EndpointResponses | null {
    // ... ジェネリック型Reply抽出ロジック
  }

  /**
   * return文からレスポンスを抽出
   */
  private extractReturnStatements(
    node: Node,
    responses: ResponseInfo[]
  ): void {
    // ... 実装
  }

  /**
   * reply.send() / reply.code().send() を抽出
   */
  private extractReplySendCalls(
    node: Node,
    successResponses: ResponseInfo[],
    errorResponses: ErrorResponseInfo[]
  ): void {
    // ... 実装
  }

  /**
   * reply.code(xxx).send(data) パターンを解析
   */
  private parseSendCall(call: CallExpression): {
    code: number;
    dataType: readonly ParamInfo[];
    lineNumber: number;
  } | null {
    // ... 実装
  }

  /**
   * エラーメッセージを抽出
   */
  private extractErrorMessage(dataType: readonly ParamInfo[]): string {
    // messageプロパティからリテラル文字列を取得
    const messageProp = dataType.find(p => p.name === 'message');
    if (messageProp && messageProp.type.startsWith("'")) {
      return messageProp.type.replace(/'/g, '');
    }
    // 型名を返す
    return messageProp?.type ?? 'string';
  }

  // ... その他のプライベートメソッド
}
```

---

## 抽出アルゴリズム詳細

### extractReturnStatements

```typescript
private extractReturnStatements(
  node: Node,
  responses: ResponseInfo[]
): void {
  node.forEachDescendant(child => {
    if (!Node.isReturnStatement(child)) {
      return;
    }

    const expr = child.getExpression();
    if (!expr) {
      return;  // return; のみ（voidリターン）
    }

    // 条件分岐内かどうかでステータスコードを推定
    const isInErrorBranch = this.isInErrorBranch(child);
    const code = isInErrorBranch ? 400 : 200;

    const dataType = this.typeExtractor.extractFromExpression(expr);
    responses.push({
      code,
      dataType,
      source: 'return',
      lineNumber: child.getStartLineNumber(),
    });
  });
}
```

### extractReplySendCalls

```typescript
private extractReplySendCalls(
  node: Node,
  successResponses: ResponseInfo[],
  errorResponses: ErrorResponseInfo[]
): void {
  node.forEachDescendant(child => {
    if (!Node.isCallExpression(child)) {
      return;
    }

    const sendInfo = this.parseSendCall(child);
    if (!sendInfo) {
      return;
    }

    const { code, dataType, lineNumber } = sendInfo;

    if (code >= 400) {
      // エラーレスポンス
      const message = this.extractErrorMessage(dataType);
      errorResponses.push({
        code,
        message,
        dataType: dataType.filter(p => p.name !== 'error' && p.name !== 'message'),
        lineNumber,
      });
    } else {
      // 成功レスポンス
      successResponses.push({
        code,
        dataType,
        source: 'reply.code',
        lineNumber,
      });
    }
  });
}
```

### parseSendCall

```typescript
private parseSendCall(call: CallExpression): {
  code: number;
  dataType: readonly ParamInfo[];
  lineNumber: number;
} | null {
  const expr = call.getExpression();

  // reply.send(data) - 暗黙の200
  if (Node.isPropertyAccessExpression(expr) && expr.getName() === 'send') {
    const object = expr.getExpression();
    if (Node.isIdentifier(object) && object.getText() === 'reply') {
      const args = call.getArguments();
      return {
        code: 200,
        dataType: args.length > 0
          ? this.typeExtractor.extractFromExpression(args[0])
          : [],
        lineNumber: call.getStartLineNumber(),
      };
    }
  }

  // reply.code(xxx).send(data)
  if (Node.isPropertyAccessExpression(expr) && expr.getName() === 'send') {
    const codeCall = expr.getExpression();
    if (Node.isCallExpression(codeCall)) {
      const codeExpr = codeCall.getExpression();
      if (Node.isPropertyAccessExpression(codeExpr)) {
        const methodName = codeExpr.getName();
        if (methodName === 'code' || methodName === 'status') {
          const codeArgs = codeCall.getArguments();
          if (codeArgs.length > 0 && Node.isNumericLiteral(codeArgs[0])) {
            const code = parseInt(codeArgs[0].getText(), 10);
            const sendArgs = call.getArguments();
            return {
              code,
              dataType: sendArgs.length > 0
                ? this.typeExtractor.extractFromExpression(sendArgs[0])
                : [],
              lineNumber: call.getStartLineNumber(),
            };
          }
        }
      }
    }
  }

  return null;
}
```

### extractFromGenericType

```typescript
extractFromGenericType(call: CallExpression): EndpointResponses | null {
  const typeArgs = call.getTypeArguments();
  if (typeArgs.length === 0) {
    return null;
  }

  const typeArg = typeArgs[0];
  const type = typeArg.getType();
  const properties = type.getProperties();

  const replyProp = properties.find(p => p.getName() === 'Reply');
  if (!replyProp) {
    return null;
  }

  const replyType = replyProp.getValueDeclaration()?.getType();
  if (!replyType) {
    return null;
  }

  // ユニオン型の場合、各型を分析
  if (replyType.isUnion()) {
    const successResponses: ResponseInfo[] = [];
    const errorResponses: ErrorResponseInfo[] = [];

    for (const t of replyType.getUnionTypes()) {
      const props = this.typeExtractor.extractFromType(t);
      const hasError = props.some(p => p.name === 'error' || p.name === 'message');

      if (hasError) {
        errorResponses.push({
          code: this.inferCodeFromType(t) ?? 400,
          message: this.extractMessageFromType(t) ?? 'string',
          dataType: props,
          lineNumber: call.getStartLineNumber(),
        });
      } else {
        successResponses.push({
          code: 200,
          dataType: props,
          typeName: t.getSymbol()?.getName(),
          source: 'generic',
          lineNumber: call.getStartLineNumber(),
        });
      }
    }

    return { success: successResponses, errors: errorResponses };
  }

  // 単一型の場合
  const props = this.typeExtractor.extractFromType(replyType);
  return {
    success: [{
      code: 200,
      dataType: props,
      typeName: replyType.getSymbol()?.getName(),
      source: 'generic',
      lineNumber: call.getStartLineNumber(),
    }],
    errors: [],
  };
}
```

---

## RouteFileParserへの統合

### 変更点

```typescript
// src/extractors/fastify/routeFileParser.ts

import { ResponseExtractor } from './responseExtractor';

export class RouteFileParser {
  private readonly responseExtractor: ResponseExtractor;

  constructor(
    sourceFile: SourceFile,
    private readonly options: ExtractorOptions
  ) {
    // 既存の初期化...
    this.responseExtractor = new ResponseExtractor(sourceFile);
  }

  private parseEndpoint(call: CallExpression, prefix: string): EndpointInfo {
    // 既存のパラメータ抽出...

    // レスポンス抽出（オプションが有効な場合のみ）
    let responses: EndpointResponses | undefined;
    if (this.options.extractResponses) {
      const handler = this.getHandlerFunction(call);
      if (handler) {
        responses = this.responseExtractor.extractFromHandler(handler);

        // ジェネリック型からも抽出してマージ
        const genericResponses = this.responseExtractor.extractFromGenericType(call);
        if (genericResponses) {
          responses = this.mergeResponses(genericResponses, responses);
        }
      }
    }

    return {
      // 既存フィールド...
      responses,
    };
  }

  private getHandlerFunction(call: CallExpression): ArrowFunction | FunctionExpression | null {
    // server.get(path, handler) または server.get(path, options, handler)
    const args = call.getArguments();

    // 最後の引数がハンドラー
    const lastArg = args[args.length - 1];
    if (Node.isArrowFunction(lastArg) || Node.isFunctionExpression(lastArg)) {
      return lastArg;
    }

    return null;
  }

  private mergeResponses(
    generic: EndpointResponses,
    body: EndpointResponses
  ): EndpointResponses {
    // ジェネリック型があればそれを優先
    if (generic.success.length > 0) {
      return {
        success: generic.success,
        errors: [...generic.errors, ...body.errors],
      };
    }
    return body;
  }
}
```

---

## 抽出優先順位

1. **ジェネリック型（Reply）**: 最も信頼性が高い
2. **reply.code().send()**: 明示的なステータスコード
3. **reply.send()**: 暗黙の200
4. **return文**: 暗黙の200（エラーブランチは推定）

---

## パフォーマンス最適化

### 基本原則

現状の軽量な動作を維持するため、以下の最適化を必須とする。

### 最適化実装

```typescript
// src/extractors/fastify/responseExtractor.ts

export class ResponseExtractor {
  // 型情報キャッシュ（重複解析回避）
  private readonly typeCache = new Map<Node, readonly ParamInfo[]>();

  extractFromHandler(
    handlerNode: ArrowFunction | FunctionExpression,
    options: ResponseExtractorOptions
  ): EndpointResponses {
    const successResponses: ResponseInfo[] = [];
    const errorResponses: ErrorResponseInfo[] = [];

    // 単一パス処理: forEachDescendantは1回のみ
    handlerNode.forEachDescendant(node => {
      // ノードフィルタリング: SyntaxKindで早期判定
      const kind = node.getKind();

      // Phase 1: 基本パターン
      if (kind === SyntaxKind.ReturnStatement) {
        this.processReturnStatement(node, successResponses);
        return;
      }

      if (kind === SyntaxKind.CallExpression) {
        this.processCallExpression(node, successResponses, errorResponses, options);
        return;
      }

      // 不要なノードは即座にスキップ（早期終了）
    });

    return {
      success: this.deduplicateResponses(successResponses),
      errors: this.deduplicateErrors(errorResponses),
    };
  }

  // 型情報のキャッシュ付き取得
  private getCachedType(node: Node): readonly ParamInfo[] {
    const cached = this.typeCache.get(node);
    if (cached) {
      return cached;
    }
    const result = this.typeExtractor.extractFromExpression(node);
    this.typeCache.set(node, result);
    return result;
  }
}
```

### RouteFileParserでのオプション分岐

```typescript
// src/extractors/fastify/routeFileParser.ts

private parseEndpoint(call: CallExpression, prefix: string): EndpointInfo {
  // 既存のパラメータ抽出...

  // オプション未指定時は一切処理しない（ゼロコスト）
  if (!this.options.extractResponses) {
    return {
      // 既存フィールド...
      responses: undefined,
    };
  }

  // レスポンス抽出実行
  const handler = this.getHandlerFunction(call);
  if (!handler) {
    return { /* ... */ responses: undefined };
  }

  const responses = this.responseExtractor.extractFromHandler(handler, {
    enableVariableTracking: true,  // Phase 2: 自動有効
    enableDeepAnalysis: this.options.deepAnalysis ?? false,  // Phase 3: 明示的有効化
  });

  // ...
}
```

---

## Phase 2: 変数追跡

### 対象パターン

```typescript
// パターン1: 動的なステータスコード
const status = 404;
reply.code(status).send(data);

// パターン2: 変数経由のレスポンス
const response = { error: 'FAIL' };
reply.send(response);
```

### 実装方針

```typescript
private resolveVariableValue(node: Node): number | undefined {
  // 変数参照の場合、定義を逆参照
  if (Node.isIdentifier(node)) {
    const definitions = node.getDefinitionNodes();
    for (const def of definitions) {
      if (Node.isVariableDeclaration(def)) {
        const initializer = def.getInitializer();
        if (initializer && Node.isNumericLiteral(initializer)) {
          return parseInt(initializer.getText(), 10);
        }
      }
    }
  }
  return undefined;
}

private resolveVariableType(node: Node): readonly ParamInfo[] {
  if (Node.isIdentifier(node)) {
    const definitions = node.getDefinitionNodes();
    for (const def of definitions) {
      if (Node.isVariableDeclaration(def)) {
        const initializer = def.getInitializer();
        if (initializer) {
          return this.getCachedType(initializer);
        }
      }
    }
  }
  return this.getCachedType(node);
}
```

---

## Phase 3: 高度な解析

### 対象パターン

```typescript
// パターン1: 外部関数でのレスポンス
return handleResponse(reply, data);

// パターン2: 複雑な条件分岐
if (condition1) {
  if (condition2) {
    reply.code(400).send({ error: 'A' });
  } else {
    reply.code(401).send({ error: 'B' });
  }
} else {
  reply.code(200).send(data);
}
```

### 実装方針

```typescript
private analyzeExternalFunction(call: CallExpression): EndpointResponses | null {
  // `--deep-analysis` 有効時のみ実行
  const funcDef = this.resolveFunctionDefinition(call);
  if (!funcDef) {
    return null;
  }

  // 関数内部を再帰的に解析
  return this.extractFromHandler(funcDef, { enableDeepAnalysis: true });
}

private resolveFunctionDefinition(call: CallExpression): ArrowFunction | FunctionExpression | null {
  const expr = call.getExpression();
  if (!Node.isIdentifier(expr)) {
    return null;
  }

  const definitions = expr.getDefinitionNodes();
  for (const def of definitions) {
    // 同一ファイル内の関数のみ追跡（パフォーマンス制限）
    if (def.getSourceFile() !== this.sourceFile) {
      continue;
    }
    if (Node.isFunctionDeclaration(def)) {
      return def;
    }
  }
  return null;
}
```

### パフォーマンス制限

- 同一ファイル内の関数のみ追跡
- 再帰深度の制限（デフォルト: 3）
- `--deep-analysis-depth <n>` オプションで調整可能

---

## 変更対象ファイル

| ファイル | 変更種別 | 内容 |
|----------|---------|------|
| `src/extractors/fastify/responseExtractor.ts` | 新規 | ResponseExtractorクラス |
| `src/extractors/fastify/routeFileParser.ts` | 修正 | ResponseExtractor統合 |
| `src/core/typeExtractor.ts` | 修正 | extractFromExpression追加（必要に応じて） |

## 完了条件

- [ ] ResponseExtractorクラスが実装されている
- [ ] 全テストがパスする
- [ ] RouteFileParserに統合されている
- [ ] extractResponsesオプションで制御できる
